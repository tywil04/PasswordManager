// Code generated by ent, DO NOT EDIT.

package ent

import (
	"PasswordManager/ent/additionalfield"
	"PasswordManager/ent/challenge"
	"PasswordManager/ent/emailchallenge"
	"PasswordManager/ent/password"
	"PasswordManager/ent/predicate"
	"PasswordManager/ent/session"
	"PasswordManager/ent/totpcredential"
	"PasswordManager/ent/url"
	"PasswordManager/ent/user"
	"PasswordManager/ent/vault"
	"PasswordManager/ent/webauthnchallenge"
	"PasswordManager/ent/webauthncredential"
	"PasswordManager/ent/webauthnregisterchallenge"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdditionalField           = "AdditionalField"
	TypeChallenge                 = "Challenge"
	TypeEmailChallenge            = "EmailChallenge"
	TypePassword                  = "Password"
	TypeSession                   = "Session"
	TypeTotpCredential            = "TotpCredential"
	TypeURL                       = "Url"
	TypeUser                      = "User"
	TypeVault                     = "Vault"
	TypeWebAuthnChallenge         = "WebAuthnChallenge"
	TypeWebAuthnCredential        = "WebAuthnCredential"
	TypeWebAuthnRegisterChallenge = "WebAuthnRegisterChallenge"
)

// AdditionalFieldMutation represents an operation that mutates the AdditionalField nodes in the graph.
type AdditionalFieldMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	key             *[]byte
	keyIv           *[]byte
	value           *[]byte
	valueIv         *[]byte
	clearedFields   map[string]struct{}
	password        *uuid.UUID
	clearedpassword bool
	done            bool
	oldValue        func(context.Context) (*AdditionalField, error)
	predicates      []predicate.AdditionalField
}

var _ ent.Mutation = (*AdditionalFieldMutation)(nil)

// additionalfieldOption allows management of the mutation configuration using functional options.
type additionalfieldOption func(*AdditionalFieldMutation)

// newAdditionalFieldMutation creates new mutation for the AdditionalField entity.
func newAdditionalFieldMutation(c config, op Op, opts ...additionalfieldOption) *AdditionalFieldMutation {
	m := &AdditionalFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeAdditionalField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdditionalFieldID sets the ID field of the mutation.
func withAdditionalFieldID(id uuid.UUID) additionalfieldOption {
	return func(m *AdditionalFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *AdditionalField
		)
		m.oldValue = func(ctx context.Context) (*AdditionalField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdditionalField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdditionalField sets the old AdditionalField of the mutation.
func withAdditionalField(node *AdditionalField) additionalfieldOption {
	return func(m *AdditionalFieldMutation) {
		m.oldValue = func(context.Context) (*AdditionalField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdditionalFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdditionalFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdditionalField entities.
func (m *AdditionalFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdditionalFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdditionalFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdditionalField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *AdditionalFieldMutation) SetKey(b []byte) {
	m.key = &b
}

// Key returns the value of the "key" field in the mutation.
func (m *AdditionalFieldMutation) Key() (r []byte, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *AdditionalFieldMutation) ResetKey() {
	m.key = nil
}

// SetKeyIv sets the "keyIv" field.
func (m *AdditionalFieldMutation) SetKeyIv(b []byte) {
	m.keyIv = &b
}

// KeyIv returns the value of the "keyIv" field in the mutation.
func (m *AdditionalFieldMutation) KeyIv() (r []byte, exists bool) {
	v := m.keyIv
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyIv returns the old "keyIv" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldKeyIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyIv: %w", err)
	}
	return oldValue.KeyIv, nil
}

// ResetKeyIv resets all changes to the "keyIv" field.
func (m *AdditionalFieldMutation) ResetKeyIv() {
	m.keyIv = nil
}

// SetValue sets the "value" field.
func (m *AdditionalFieldMutation) SetValue(b []byte) {
	m.value = &b
}

// Value returns the value of the "value" field in the mutation.
func (m *AdditionalFieldMutation) Value() (r []byte, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldValue(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AdditionalFieldMutation) ResetValue() {
	m.value = nil
}

// SetValueIv sets the "valueIv" field.
func (m *AdditionalFieldMutation) SetValueIv(b []byte) {
	m.valueIv = &b
}

// ValueIv returns the value of the "valueIv" field in the mutation.
func (m *AdditionalFieldMutation) ValueIv() (r []byte, exists bool) {
	v := m.valueIv
	if v == nil {
		return
	}
	return *v, true
}

// OldValueIv returns the old "valueIv" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldValueIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueIv: %w", err)
	}
	return oldValue.ValueIv, nil
}

// ResetValueIv resets all changes to the "valueIv" field.
func (m *AdditionalFieldMutation) ResetValueIv() {
	m.valueIv = nil
}

// SetPasswordID sets the "password" edge to the Password entity by id.
func (m *AdditionalFieldMutation) SetPasswordID(id uuid.UUID) {
	m.password = &id
}

// ClearPassword clears the "password" edge to the Password entity.
func (m *AdditionalFieldMutation) ClearPassword() {
	m.clearedpassword = true
}

// PasswordCleared reports if the "password" edge to the Password entity was cleared.
func (m *AdditionalFieldMutation) PasswordCleared() bool {
	return m.clearedpassword
}

// PasswordID returns the "password" edge ID in the mutation.
func (m *AdditionalFieldMutation) PasswordID() (id uuid.UUID, exists bool) {
	if m.password != nil {
		return *m.password, true
	}
	return
}

// PasswordIDs returns the "password" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PasswordID instead. It exists only for internal usage by the builders.
func (m *AdditionalFieldMutation) PasswordIDs() (ids []uuid.UUID) {
	if id := m.password; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPassword resets all changes to the "password" edge.
func (m *AdditionalFieldMutation) ResetPassword() {
	m.password = nil
	m.clearedpassword = false
}

// Where appends a list predicates to the AdditionalFieldMutation builder.
func (m *AdditionalFieldMutation) Where(ps ...predicate.AdditionalField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdditionalFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdditionalFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdditionalField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdditionalFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdditionalFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdditionalField).
func (m *AdditionalFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdditionalFieldMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.key != nil {
		fields = append(fields, additionalfield.FieldKey)
	}
	if m.keyIv != nil {
		fields = append(fields, additionalfield.FieldKeyIv)
	}
	if m.value != nil {
		fields = append(fields, additionalfield.FieldValue)
	}
	if m.valueIv != nil {
		fields = append(fields, additionalfield.FieldValueIv)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdditionalFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case additionalfield.FieldKey:
		return m.Key()
	case additionalfield.FieldKeyIv:
		return m.KeyIv()
	case additionalfield.FieldValue:
		return m.Value()
	case additionalfield.FieldValueIv:
		return m.ValueIv()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdditionalFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case additionalfield.FieldKey:
		return m.OldKey(ctx)
	case additionalfield.FieldKeyIv:
		return m.OldKeyIv(ctx)
	case additionalfield.FieldValue:
		return m.OldValue(ctx)
	case additionalfield.FieldValueIv:
		return m.OldValueIv(ctx)
	}
	return nil, fmt.Errorf("unknown AdditionalField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdditionalFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case additionalfield.FieldKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case additionalfield.FieldKeyIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyIv(v)
		return nil
	case additionalfield.FieldValue:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case additionalfield.FieldValueIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueIv(v)
		return nil
	}
	return fmt.Errorf("unknown AdditionalField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdditionalFieldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdditionalFieldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdditionalFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdditionalField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdditionalFieldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdditionalFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdditionalFieldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdditionalField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdditionalFieldMutation) ResetField(name string) error {
	switch name {
	case additionalfield.FieldKey:
		m.ResetKey()
		return nil
	case additionalfield.FieldKeyIv:
		m.ResetKeyIv()
		return nil
	case additionalfield.FieldValue:
		m.ResetValue()
		return nil
	case additionalfield.FieldValueIv:
		m.ResetValueIv()
		return nil
	}
	return fmt.Errorf("unknown AdditionalField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdditionalFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.password != nil {
		edges = append(edges, additionalfield.EdgePassword)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdditionalFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case additionalfield.EdgePassword:
		if id := m.password; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdditionalFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdditionalFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdditionalFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpassword {
		edges = append(edges, additionalfield.EdgePassword)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdditionalFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case additionalfield.EdgePassword:
		return m.clearedpassword
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdditionalFieldMutation) ClearEdge(name string) error {
	switch name {
	case additionalfield.EdgePassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown AdditionalField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdditionalFieldMutation) ResetEdge(name string) error {
	switch name {
	case additionalfield.EdgePassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown AdditionalField edge %s", name)
}

// ChallengeMutation represents an operation that mutates the Challenge nodes in the graph.
type ChallengeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	expiry                   *time.Time
	clearedFields            map[string]struct{}
	user                     *uuid.UUID
	cleareduser              bool
	emailChallenge           *uuid.UUID
	clearedemailChallenge    bool
	webauthnChallenge        *uuid.UUID
	clearedwebauthnChallenge bool
	totpCredential           *uuid.UUID
	clearedtotpCredential    bool
	done                     bool
	oldValue                 func(context.Context) (*Challenge, error)
	predicates               []predicate.Challenge
}

var _ ent.Mutation = (*ChallengeMutation)(nil)

// challengeOption allows management of the mutation configuration using functional options.
type challengeOption func(*ChallengeMutation)

// newChallengeMutation creates new mutation for the Challenge entity.
func newChallengeMutation(c config, op Op, opts ...challengeOption) *ChallengeMutation {
	m := &ChallengeMutation{
		config:        c,
		op:            op,
		typ:           TypeChallenge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChallengeID sets the ID field of the mutation.
func withChallengeID(id uuid.UUID) challengeOption {
	return func(m *ChallengeMutation) {
		var (
			err   error
			once  sync.Once
			value *Challenge
		)
		m.oldValue = func(ctx context.Context) (*Challenge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Challenge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChallenge sets the old Challenge of the mutation.
func withChallenge(node *Challenge) challengeOption {
	return func(m *ChallengeMutation) {
		m.oldValue = func(context.Context) (*Challenge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChallengeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChallengeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Challenge entities.
func (m *ChallengeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChallengeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChallengeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Challenge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpiry sets the "expiry" field.
func (m *ChallengeMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *ChallengeMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Challenge entity.
// If the Challenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChallengeMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *ChallengeMutation) ResetExpiry() {
	m.expiry = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ChallengeMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChallengeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChallengeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ChallengeMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChallengeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChallengeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetEmailChallengeID sets the "emailChallenge" edge to the EmailChallenge entity by id.
func (m *ChallengeMutation) SetEmailChallengeID(id uuid.UUID) {
	m.emailChallenge = &id
}

// ClearEmailChallenge clears the "emailChallenge" edge to the EmailChallenge entity.
func (m *ChallengeMutation) ClearEmailChallenge() {
	m.clearedemailChallenge = true
}

// EmailChallengeCleared reports if the "emailChallenge" edge to the EmailChallenge entity was cleared.
func (m *ChallengeMutation) EmailChallengeCleared() bool {
	return m.clearedemailChallenge
}

// EmailChallengeID returns the "emailChallenge" edge ID in the mutation.
func (m *ChallengeMutation) EmailChallengeID() (id uuid.UUID, exists bool) {
	if m.emailChallenge != nil {
		return *m.emailChallenge, true
	}
	return
}

// EmailChallengeIDs returns the "emailChallenge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailChallengeID instead. It exists only for internal usage by the builders.
func (m *ChallengeMutation) EmailChallengeIDs() (ids []uuid.UUID) {
	if id := m.emailChallenge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailChallenge resets all changes to the "emailChallenge" edge.
func (m *ChallengeMutation) ResetEmailChallenge() {
	m.emailChallenge = nil
	m.clearedemailChallenge = false
}

// SetWebauthnChallengeID sets the "webauthnChallenge" edge to the WebAuthnChallenge entity by id.
func (m *ChallengeMutation) SetWebauthnChallengeID(id uuid.UUID) {
	m.webauthnChallenge = &id
}

// ClearWebauthnChallenge clears the "webauthnChallenge" edge to the WebAuthnChallenge entity.
func (m *ChallengeMutation) ClearWebauthnChallenge() {
	m.clearedwebauthnChallenge = true
}

// WebauthnChallengeCleared reports if the "webauthnChallenge" edge to the WebAuthnChallenge entity was cleared.
func (m *ChallengeMutation) WebauthnChallengeCleared() bool {
	return m.clearedwebauthnChallenge
}

// WebauthnChallengeID returns the "webauthnChallenge" edge ID in the mutation.
func (m *ChallengeMutation) WebauthnChallengeID() (id uuid.UUID, exists bool) {
	if m.webauthnChallenge != nil {
		return *m.webauthnChallenge, true
	}
	return
}

// WebauthnChallengeIDs returns the "webauthnChallenge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WebauthnChallengeID instead. It exists only for internal usage by the builders.
func (m *ChallengeMutation) WebauthnChallengeIDs() (ids []uuid.UUID) {
	if id := m.webauthnChallenge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWebauthnChallenge resets all changes to the "webauthnChallenge" edge.
func (m *ChallengeMutation) ResetWebauthnChallenge() {
	m.webauthnChallenge = nil
	m.clearedwebauthnChallenge = false
}

// SetTotpCredentialID sets the "totpCredential" edge to the TotpCredential entity by id.
func (m *ChallengeMutation) SetTotpCredentialID(id uuid.UUID) {
	m.totpCredential = &id
}

// ClearTotpCredential clears the "totpCredential" edge to the TotpCredential entity.
func (m *ChallengeMutation) ClearTotpCredential() {
	m.clearedtotpCredential = true
}

// TotpCredentialCleared reports if the "totpCredential" edge to the TotpCredential entity was cleared.
func (m *ChallengeMutation) TotpCredentialCleared() bool {
	return m.clearedtotpCredential
}

// TotpCredentialID returns the "totpCredential" edge ID in the mutation.
func (m *ChallengeMutation) TotpCredentialID() (id uuid.UUID, exists bool) {
	if m.totpCredential != nil {
		return *m.totpCredential, true
	}
	return
}

// TotpCredentialIDs returns the "totpCredential" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TotpCredentialID instead. It exists only for internal usage by the builders.
func (m *ChallengeMutation) TotpCredentialIDs() (ids []uuid.UUID) {
	if id := m.totpCredential; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTotpCredential resets all changes to the "totpCredential" edge.
func (m *ChallengeMutation) ResetTotpCredential() {
	m.totpCredential = nil
	m.clearedtotpCredential = false
}

// Where appends a list predicates to the ChallengeMutation builder.
func (m *ChallengeMutation) Where(ps ...predicate.Challenge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChallengeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChallengeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Challenge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChallengeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChallengeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Challenge).
func (m *ChallengeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChallengeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.expiry != nil {
		fields = append(fields, challenge.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChallengeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case challenge.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChallengeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case challenge.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Challenge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChallengeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case challenge.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Challenge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChallengeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChallengeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChallengeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Challenge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChallengeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChallengeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChallengeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Challenge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChallengeMutation) ResetField(name string) error {
	switch name {
	case challenge.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown Challenge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChallengeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, challenge.EdgeUser)
	}
	if m.emailChallenge != nil {
		edges = append(edges, challenge.EdgeEmailChallenge)
	}
	if m.webauthnChallenge != nil {
		edges = append(edges, challenge.EdgeWebauthnChallenge)
	}
	if m.totpCredential != nil {
		edges = append(edges, challenge.EdgeTotpCredential)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChallengeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case challenge.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case challenge.EdgeEmailChallenge:
		if id := m.emailChallenge; id != nil {
			return []ent.Value{*id}
		}
	case challenge.EdgeWebauthnChallenge:
		if id := m.webauthnChallenge; id != nil {
			return []ent.Value{*id}
		}
	case challenge.EdgeTotpCredential:
		if id := m.totpCredential; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChallengeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChallengeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChallengeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, challenge.EdgeUser)
	}
	if m.clearedemailChallenge {
		edges = append(edges, challenge.EdgeEmailChallenge)
	}
	if m.clearedwebauthnChallenge {
		edges = append(edges, challenge.EdgeWebauthnChallenge)
	}
	if m.clearedtotpCredential {
		edges = append(edges, challenge.EdgeTotpCredential)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChallengeMutation) EdgeCleared(name string) bool {
	switch name {
	case challenge.EdgeUser:
		return m.cleareduser
	case challenge.EdgeEmailChallenge:
		return m.clearedemailChallenge
	case challenge.EdgeWebauthnChallenge:
		return m.clearedwebauthnChallenge
	case challenge.EdgeTotpCredential:
		return m.clearedtotpCredential
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChallengeMutation) ClearEdge(name string) error {
	switch name {
	case challenge.EdgeUser:
		m.ClearUser()
		return nil
	case challenge.EdgeEmailChallenge:
		m.ClearEmailChallenge()
		return nil
	case challenge.EdgeWebauthnChallenge:
		m.ClearWebauthnChallenge()
		return nil
	case challenge.EdgeTotpCredential:
		m.ClearTotpCredential()
		return nil
	}
	return fmt.Errorf("unknown Challenge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChallengeMutation) ResetEdge(name string) error {
	switch name {
	case challenge.EdgeUser:
		m.ResetUser()
		return nil
	case challenge.EdgeEmailChallenge:
		m.ResetEmailChallenge()
		return nil
	case challenge.EdgeWebauthnChallenge:
		m.ResetWebauthnChallenge()
		return nil
	case challenge.EdgeTotpCredential:
		m.ResetTotpCredential()
		return nil
	}
	return fmt.Errorf("unknown Challenge edge %s", name)
}

// EmailChallengeMutation represents an operation that mutates the EmailChallenge nodes in the graph.
type EmailChallengeMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	code             *string
	clearedFields    map[string]struct{}
	challenge        *uuid.UUID
	clearedchallenge bool
	done             bool
	oldValue         func(context.Context) (*EmailChallenge, error)
	predicates       []predicate.EmailChallenge
}

var _ ent.Mutation = (*EmailChallengeMutation)(nil)

// emailchallengeOption allows management of the mutation configuration using functional options.
type emailchallengeOption func(*EmailChallengeMutation)

// newEmailChallengeMutation creates new mutation for the EmailChallenge entity.
func newEmailChallengeMutation(c config, op Op, opts ...emailchallengeOption) *EmailChallengeMutation {
	m := &EmailChallengeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailChallenge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailChallengeID sets the ID field of the mutation.
func withEmailChallengeID(id uuid.UUID) emailchallengeOption {
	return func(m *EmailChallengeMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailChallenge
		)
		m.oldValue = func(ctx context.Context) (*EmailChallenge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailChallenge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailChallenge sets the old EmailChallenge of the mutation.
func withEmailChallenge(node *EmailChallenge) emailchallengeOption {
	return func(m *EmailChallengeMutation) {
		m.oldValue = func(context.Context) (*EmailChallenge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailChallengeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailChallengeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailChallenge entities.
func (m *EmailChallengeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailChallengeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailChallengeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailChallenge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *EmailChallengeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EmailChallengeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the EmailChallenge entity.
// If the EmailChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailChallengeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *EmailChallengeMutation) ClearCode() {
	m.code = nil
	m.clearedFields[emailchallenge.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *EmailChallengeMutation) CodeCleared() bool {
	_, ok := m.clearedFields[emailchallenge.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *EmailChallengeMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, emailchallenge.FieldCode)
}

// SetChallengeID sets the "challenge" edge to the Challenge entity by id.
func (m *EmailChallengeMutation) SetChallengeID(id uuid.UUID) {
	m.challenge = &id
}

// ClearChallenge clears the "challenge" edge to the Challenge entity.
func (m *EmailChallengeMutation) ClearChallenge() {
	m.clearedchallenge = true
}

// ChallengeCleared reports if the "challenge" edge to the Challenge entity was cleared.
func (m *EmailChallengeMutation) ChallengeCleared() bool {
	return m.clearedchallenge
}

// ChallengeID returns the "challenge" edge ID in the mutation.
func (m *EmailChallengeMutation) ChallengeID() (id uuid.UUID, exists bool) {
	if m.challenge != nil {
		return *m.challenge, true
	}
	return
}

// ChallengeIDs returns the "challenge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChallengeID instead. It exists only for internal usage by the builders.
func (m *EmailChallengeMutation) ChallengeIDs() (ids []uuid.UUID) {
	if id := m.challenge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChallenge resets all changes to the "challenge" edge.
func (m *EmailChallengeMutation) ResetChallenge() {
	m.challenge = nil
	m.clearedchallenge = false
}

// Where appends a list predicates to the EmailChallengeMutation builder.
func (m *EmailChallengeMutation) Where(ps ...predicate.EmailChallenge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailChallengeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailChallengeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailChallenge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailChallengeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailChallengeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailChallenge).
func (m *EmailChallengeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailChallengeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.code != nil {
		fields = append(fields, emailchallenge.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailChallengeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailchallenge.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailChallengeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailchallenge.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown EmailChallenge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailChallengeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailchallenge.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailChallengeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailChallengeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailChallengeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailChallenge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailChallengeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailchallenge.FieldCode) {
		fields = append(fields, emailchallenge.FieldCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailChallengeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailChallengeMutation) ClearField(name string) error {
	switch name {
	case emailchallenge.FieldCode:
		m.ClearCode()
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailChallengeMutation) ResetField(name string) error {
	switch name {
	case emailchallenge.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailChallengeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.challenge != nil {
		edges = append(edges, emailchallenge.EdgeChallenge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailChallengeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailchallenge.EdgeChallenge:
		if id := m.challenge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailChallengeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailChallengeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailChallengeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchallenge {
		edges = append(edges, emailchallenge.EdgeChallenge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailChallengeMutation) EdgeCleared(name string) bool {
	switch name {
	case emailchallenge.EdgeChallenge:
		return m.clearedchallenge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailChallengeMutation) ClearEdge(name string) error {
	switch name {
	case emailchallenge.EdgeChallenge:
		m.ClearChallenge()
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailChallengeMutation) ResetEdge(name string) error {
	switch name {
	case emailchallenge.EdgeChallenge:
		m.ResetChallenge()
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge edge %s", name)
}

// PasswordMutation represents an operation that mutates the Password nodes in the graph.
type PasswordMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	name                    *[]byte
	nameIv                  *[]byte
	username                *[]byte
	usernameIv              *[]byte
	password                *[]byte
	passwordIv              *[]byte
	colour                  *string
	clearedFields           map[string]struct{}
	additionalFields        map[uuid.UUID]struct{}
	removedadditionalFields map[uuid.UUID]struct{}
	clearedadditionalFields bool
	urls                    map[uuid.UUID]struct{}
	removedurls             map[uuid.UUID]struct{}
	clearedurls             bool
	vault                   *uuid.UUID
	clearedvault            bool
	done                    bool
	oldValue                func(context.Context) (*Password, error)
	predicates              []predicate.Password
}

var _ ent.Mutation = (*PasswordMutation)(nil)

// passwordOption allows management of the mutation configuration using functional options.
type passwordOption func(*PasswordMutation)

// newPasswordMutation creates new mutation for the Password entity.
func newPasswordMutation(c config, op Op, opts ...passwordOption) *PasswordMutation {
	m := &PasswordMutation{
		config:        c,
		op:            op,
		typ:           TypePassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordID sets the ID field of the mutation.
func withPasswordID(id uuid.UUID) passwordOption {
	return func(m *PasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *Password
		)
		m.oldValue = func(ctx context.Context) (*Password, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Password.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPassword sets the old Password of the mutation.
func withPassword(node *Password) passwordOption {
	return func(m *PasswordMutation) {
		m.oldValue = func(context.Context) (*Password, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Password entities.
func (m *PasswordMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Password.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PasswordMutation) SetName(b []byte) {
	m.name = &b
}

// Name returns the value of the "name" field in the mutation.
func (m *PasswordMutation) Name() (r []byte, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldName(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PasswordMutation) ResetName() {
	m.name = nil
}

// SetNameIv sets the "nameIv" field.
func (m *PasswordMutation) SetNameIv(b []byte) {
	m.nameIv = &b
}

// NameIv returns the value of the "nameIv" field in the mutation.
func (m *PasswordMutation) NameIv() (r []byte, exists bool) {
	v := m.nameIv
	if v == nil {
		return
	}
	return *v, true
}

// OldNameIv returns the old "nameIv" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldNameIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameIv: %w", err)
	}
	return oldValue.NameIv, nil
}

// ResetNameIv resets all changes to the "nameIv" field.
func (m *PasswordMutation) ResetNameIv() {
	m.nameIv = nil
}

// SetUsername sets the "username" field.
func (m *PasswordMutation) SetUsername(b []byte) {
	m.username = &b
}

// Username returns the value of the "username" field in the mutation.
func (m *PasswordMutation) Username() (r []byte, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUsername(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *PasswordMutation) ResetUsername() {
	m.username = nil
}

// SetUsernameIv sets the "usernameIv" field.
func (m *PasswordMutation) SetUsernameIv(b []byte) {
	m.usernameIv = &b
}

// UsernameIv returns the value of the "usernameIv" field in the mutation.
func (m *PasswordMutation) UsernameIv() (r []byte, exists bool) {
	v := m.usernameIv
	if v == nil {
		return
	}
	return *v, true
}

// OldUsernameIv returns the old "usernameIv" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUsernameIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsernameIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsernameIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsernameIv: %w", err)
	}
	return oldValue.UsernameIv, nil
}

// ResetUsernameIv resets all changes to the "usernameIv" field.
func (m *PasswordMutation) ResetUsernameIv() {
	m.usernameIv = nil
}

// SetPassword sets the "password" field.
func (m *PasswordMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *PasswordMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *PasswordMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordIv sets the "passwordIv" field.
func (m *PasswordMutation) SetPasswordIv(b []byte) {
	m.passwordIv = &b
}

// PasswordIv returns the value of the "passwordIv" field in the mutation.
func (m *PasswordMutation) PasswordIv() (r []byte, exists bool) {
	v := m.passwordIv
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordIv returns the old "passwordIv" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldPasswordIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordIv: %w", err)
	}
	return oldValue.PasswordIv, nil
}

// ResetPasswordIv resets all changes to the "passwordIv" field.
func (m *PasswordMutation) ResetPasswordIv() {
	m.passwordIv = nil
}

// SetColour sets the "colour" field.
func (m *PasswordMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *PasswordMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ResetColour resets all changes to the "colour" field.
func (m *PasswordMutation) ResetColour() {
	m.colour = nil
}

// AddAdditionalFieldIDs adds the "additionalFields" edge to the AdditionalField entity by ids.
func (m *PasswordMutation) AddAdditionalFieldIDs(ids ...uuid.UUID) {
	if m.additionalFields == nil {
		m.additionalFields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.additionalFields[ids[i]] = struct{}{}
	}
}

// ClearAdditionalFields clears the "additionalFields" edge to the AdditionalField entity.
func (m *PasswordMutation) ClearAdditionalFields() {
	m.clearedadditionalFields = true
}

// AdditionalFieldsCleared reports if the "additionalFields" edge to the AdditionalField entity was cleared.
func (m *PasswordMutation) AdditionalFieldsCleared() bool {
	return m.clearedadditionalFields
}

// RemoveAdditionalFieldIDs removes the "additionalFields" edge to the AdditionalField entity by IDs.
func (m *PasswordMutation) RemoveAdditionalFieldIDs(ids ...uuid.UUID) {
	if m.removedadditionalFields == nil {
		m.removedadditionalFields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.additionalFields, ids[i])
		m.removedadditionalFields[ids[i]] = struct{}{}
	}
}

// RemovedAdditionalFields returns the removed IDs of the "additionalFields" edge to the AdditionalField entity.
func (m *PasswordMutation) RemovedAdditionalFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedadditionalFields {
		ids = append(ids, id)
	}
	return
}

// AdditionalFieldsIDs returns the "additionalFields" edge IDs in the mutation.
func (m *PasswordMutation) AdditionalFieldsIDs() (ids []uuid.UUID) {
	for id := range m.additionalFields {
		ids = append(ids, id)
	}
	return
}

// ResetAdditionalFields resets all changes to the "additionalFields" edge.
func (m *PasswordMutation) ResetAdditionalFields() {
	m.additionalFields = nil
	m.clearedadditionalFields = false
	m.removedadditionalFields = nil
}

// AddURLIDs adds the "urls" edge to the Url entity by ids.
func (m *PasswordMutation) AddURLIDs(ids ...uuid.UUID) {
	if m.urls == nil {
		m.urls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.urls[ids[i]] = struct{}{}
	}
}

// ClearUrls clears the "urls" edge to the Url entity.
func (m *PasswordMutation) ClearUrls() {
	m.clearedurls = true
}

// UrlsCleared reports if the "urls" edge to the Url entity was cleared.
func (m *PasswordMutation) UrlsCleared() bool {
	return m.clearedurls
}

// RemoveURLIDs removes the "urls" edge to the Url entity by IDs.
func (m *PasswordMutation) RemoveURLIDs(ids ...uuid.UUID) {
	if m.removedurls == nil {
		m.removedurls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.urls, ids[i])
		m.removedurls[ids[i]] = struct{}{}
	}
}

// RemovedUrls returns the removed IDs of the "urls" edge to the Url entity.
func (m *PasswordMutation) RemovedUrlsIDs() (ids []uuid.UUID) {
	for id := range m.removedurls {
		ids = append(ids, id)
	}
	return
}

// UrlsIDs returns the "urls" edge IDs in the mutation.
func (m *PasswordMutation) UrlsIDs() (ids []uuid.UUID) {
	for id := range m.urls {
		ids = append(ids, id)
	}
	return
}

// ResetUrls resets all changes to the "urls" edge.
func (m *PasswordMutation) ResetUrls() {
	m.urls = nil
	m.clearedurls = false
	m.removedurls = nil
}

// SetVaultID sets the "vault" edge to the Vault entity by id.
func (m *PasswordMutation) SetVaultID(id uuid.UUID) {
	m.vault = &id
}

// ClearVault clears the "vault" edge to the Vault entity.
func (m *PasswordMutation) ClearVault() {
	m.clearedvault = true
}

// VaultCleared reports if the "vault" edge to the Vault entity was cleared.
func (m *PasswordMutation) VaultCleared() bool {
	return m.clearedvault
}

// VaultID returns the "vault" edge ID in the mutation.
func (m *PasswordMutation) VaultID() (id uuid.UUID, exists bool) {
	if m.vault != nil {
		return *m.vault, true
	}
	return
}

// VaultIDs returns the "vault" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VaultID instead. It exists only for internal usage by the builders.
func (m *PasswordMutation) VaultIDs() (ids []uuid.UUID) {
	if id := m.vault; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVault resets all changes to the "vault" edge.
func (m *PasswordMutation) ResetVault() {
	m.vault = nil
	m.clearedvault = false
}

// Where appends a list predicates to the PasswordMutation builder.
func (m *PasswordMutation) Where(ps ...predicate.Password) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Password, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Password).
func (m *PasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, password.FieldName)
	}
	if m.nameIv != nil {
		fields = append(fields, password.FieldNameIv)
	}
	if m.username != nil {
		fields = append(fields, password.FieldUsername)
	}
	if m.usernameIv != nil {
		fields = append(fields, password.FieldUsernameIv)
	}
	if m.password != nil {
		fields = append(fields, password.FieldPassword)
	}
	if m.passwordIv != nil {
		fields = append(fields, password.FieldPasswordIv)
	}
	if m.colour != nil {
		fields = append(fields, password.FieldColour)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case password.FieldName:
		return m.Name()
	case password.FieldNameIv:
		return m.NameIv()
	case password.FieldUsername:
		return m.Username()
	case password.FieldUsernameIv:
		return m.UsernameIv()
	case password.FieldPassword:
		return m.Password()
	case password.FieldPasswordIv:
		return m.PasswordIv()
	case password.FieldColour:
		return m.Colour()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case password.FieldName:
		return m.OldName(ctx)
	case password.FieldNameIv:
		return m.OldNameIv(ctx)
	case password.FieldUsername:
		return m.OldUsername(ctx)
	case password.FieldUsernameIv:
		return m.OldUsernameIv(ctx)
	case password.FieldPassword:
		return m.OldPassword(ctx)
	case password.FieldPasswordIv:
		return m.OldPasswordIv(ctx)
	case password.FieldColour:
		return m.OldColour(ctx)
	}
	return nil, fmt.Errorf("unknown Password field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case password.FieldName:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case password.FieldNameIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameIv(v)
		return nil
	case password.FieldUsername:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case password.FieldUsernameIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsernameIv(v)
		return nil
	case password.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case password.FieldPasswordIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordIv(v)
		return nil
	case password.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Password numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Password nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordMutation) ResetField(name string) error {
	switch name {
	case password.FieldName:
		m.ResetName()
		return nil
	case password.FieldNameIv:
		m.ResetNameIv()
		return nil
	case password.FieldUsername:
		m.ResetUsername()
		return nil
	case password.FieldUsernameIv:
		m.ResetUsernameIv()
		return nil
	case password.FieldPassword:
		m.ResetPassword()
		return nil
	case password.FieldPasswordIv:
		m.ResetPasswordIv()
		return nil
	case password.FieldColour:
		m.ResetColour()
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.additionalFields != nil {
		edges = append(edges, password.EdgeAdditionalFields)
	}
	if m.urls != nil {
		edges = append(edges, password.EdgeUrls)
	}
	if m.vault != nil {
		edges = append(edges, password.EdgeVault)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case password.EdgeAdditionalFields:
		ids := make([]ent.Value, 0, len(m.additionalFields))
		for id := range m.additionalFields {
			ids = append(ids, id)
		}
		return ids
	case password.EdgeUrls:
		ids := make([]ent.Value, 0, len(m.urls))
		for id := range m.urls {
			ids = append(ids, id)
		}
		return ids
	case password.EdgeVault:
		if id := m.vault; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedadditionalFields != nil {
		edges = append(edges, password.EdgeAdditionalFields)
	}
	if m.removedurls != nil {
		edges = append(edges, password.EdgeUrls)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case password.EdgeAdditionalFields:
		ids := make([]ent.Value, 0, len(m.removedadditionalFields))
		for id := range m.removedadditionalFields {
			ids = append(ids, id)
		}
		return ids
	case password.EdgeUrls:
		ids := make([]ent.Value, 0, len(m.removedurls))
		for id := range m.removedurls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedadditionalFields {
		edges = append(edges, password.EdgeAdditionalFields)
	}
	if m.clearedurls {
		edges = append(edges, password.EdgeUrls)
	}
	if m.clearedvault {
		edges = append(edges, password.EdgeVault)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordMutation) EdgeCleared(name string) bool {
	switch name {
	case password.EdgeAdditionalFields:
		return m.clearedadditionalFields
	case password.EdgeUrls:
		return m.clearedurls
	case password.EdgeVault:
		return m.clearedvault
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordMutation) ClearEdge(name string) error {
	switch name {
	case password.EdgeVault:
		m.ClearVault()
		return nil
	}
	return fmt.Errorf("unknown Password unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordMutation) ResetEdge(name string) error {
	switch name {
	case password.EdgeAdditionalFields:
		m.ResetAdditionalFields()
		return nil
	case password.EdgeUrls:
		m.ResetUrls()
		return nil
	case password.EdgeVault:
		m.ResetVault()
		return nil
	}
	return fmt.Errorf("unknown Password edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	n             *[]byte
	e             *int
	adde          *int
	expiry        *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetN sets the "n" field.
func (m *SessionMutation) SetN(b []byte) {
	m.n = &b
}

// N returns the value of the "n" field in the mutation.
func (m *SessionMutation) N() (r []byte, exists bool) {
	v := m.n
	if v == nil {
		return
	}
	return *v, true
}

// OldN returns the old "n" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldN(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldN: %w", err)
	}
	return oldValue.N, nil
}

// ResetN resets all changes to the "n" field.
func (m *SessionMutation) ResetN() {
	m.n = nil
}

// SetE sets the "e" field.
func (m *SessionMutation) SetE(i int) {
	m.e = &i
	m.adde = nil
}

// E returns the value of the "e" field in the mutation.
func (m *SessionMutation) E() (r int, exists bool) {
	v := m.e
	if v == nil {
		return
	}
	return *v, true
}

// OldE returns the old "e" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldE(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldE is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldE: %w", err)
	}
	return oldValue.E, nil
}

// AddE adds i to the "e" field.
func (m *SessionMutation) AddE(i int) {
	if m.adde != nil {
		*m.adde += i
	} else {
		m.adde = &i
	}
}

// AddedE returns the value that was added to the "e" field in this mutation.
func (m *SessionMutation) AddedE() (r int, exists bool) {
	v := m.adde
	if v == nil {
		return
	}
	return *v, true
}

// ResetE resets all changes to the "e" field.
func (m *SessionMutation) ResetE() {
	m.e = nil
	m.adde = nil
}

// SetExpiry sets the "expiry" field.
func (m *SessionMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *SessionMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *SessionMutation) ResetExpiry() {
	m.expiry = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SessionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SessionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.n != nil {
		fields = append(fields, session.FieldN)
	}
	if m.e != nil {
		fields = append(fields, session.FieldE)
	}
	if m.expiry != nil {
		fields = append(fields, session.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldN:
		return m.N()
	case session.FieldE:
		return m.E()
	case session.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldN:
		return m.OldN(ctx)
	case session.FieldE:
		return m.OldE(ctx)
	case session.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldN:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetN(v)
		return nil
	case session.FieldE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetE(v)
		return nil
	case session.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.adde != nil {
		fields = append(fields, session.FieldE)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldE:
		return m.AddedE()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddE(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldN:
		m.ResetN()
		return nil
	case session.FieldE:
		m.ResetE()
		return nil
	case session.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// TotpCredentialMutation represents an operation that mutates the TotpCredential nodes in the graph.
type TotpCredentialMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	createdAt        *time.Time
	secret           *string
	validated        *bool
	clearedFields    map[string]struct{}
	user             *uuid.UUID
	cleareduser      bool
	challenge        *uuid.UUID
	clearedchallenge bool
	done             bool
	oldValue         func(context.Context) (*TotpCredential, error)
	predicates       []predicate.TotpCredential
}

var _ ent.Mutation = (*TotpCredentialMutation)(nil)

// totpcredentialOption allows management of the mutation configuration using functional options.
type totpcredentialOption func(*TotpCredentialMutation)

// newTotpCredentialMutation creates new mutation for the TotpCredential entity.
func newTotpCredentialMutation(c config, op Op, opts ...totpcredentialOption) *TotpCredentialMutation {
	m := &TotpCredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeTotpCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTotpCredentialID sets the ID field of the mutation.
func withTotpCredentialID(id uuid.UUID) totpcredentialOption {
	return func(m *TotpCredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *TotpCredential
		)
		m.oldValue = func(ctx context.Context) (*TotpCredential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TotpCredential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTotpCredential sets the old TotpCredential of the mutation.
func withTotpCredential(node *TotpCredential) totpcredentialOption {
	return func(m *TotpCredentialMutation) {
		m.oldValue = func(context.Context) (*TotpCredential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TotpCredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TotpCredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TotpCredential entities.
func (m *TotpCredentialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TotpCredentialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TotpCredentialMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TotpCredential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *TotpCredentialMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TotpCredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the TotpCredential entity.
// If the TotpCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TotpCredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TotpCredentialMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetSecret sets the "secret" field.
func (m *TotpCredentialMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *TotpCredentialMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the TotpCredential entity.
// If the TotpCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TotpCredentialMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *TotpCredentialMutation) ResetSecret() {
	m.secret = nil
}

// SetValidated sets the "validated" field.
func (m *TotpCredentialMutation) SetValidated(b bool) {
	m.validated = &b
}

// Validated returns the value of the "validated" field in the mutation.
func (m *TotpCredentialMutation) Validated() (r bool, exists bool) {
	v := m.validated
	if v == nil {
		return
	}
	return *v, true
}

// OldValidated returns the old "validated" field's value of the TotpCredential entity.
// If the TotpCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TotpCredentialMutation) OldValidated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidated: %w", err)
	}
	return oldValue.Validated, nil
}

// ResetValidated resets all changes to the "validated" field.
func (m *TotpCredentialMutation) ResetValidated() {
	m.validated = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TotpCredentialMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TotpCredentialMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TotpCredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TotpCredentialMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TotpCredentialMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TotpCredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetChallengeID sets the "challenge" edge to the Challenge entity by id.
func (m *TotpCredentialMutation) SetChallengeID(id uuid.UUID) {
	m.challenge = &id
}

// ClearChallenge clears the "challenge" edge to the Challenge entity.
func (m *TotpCredentialMutation) ClearChallenge() {
	m.clearedchallenge = true
}

// ChallengeCleared reports if the "challenge" edge to the Challenge entity was cleared.
func (m *TotpCredentialMutation) ChallengeCleared() bool {
	return m.clearedchallenge
}

// ChallengeID returns the "challenge" edge ID in the mutation.
func (m *TotpCredentialMutation) ChallengeID() (id uuid.UUID, exists bool) {
	if m.challenge != nil {
		return *m.challenge, true
	}
	return
}

// ChallengeIDs returns the "challenge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChallengeID instead. It exists only for internal usage by the builders.
func (m *TotpCredentialMutation) ChallengeIDs() (ids []uuid.UUID) {
	if id := m.challenge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChallenge resets all changes to the "challenge" edge.
func (m *TotpCredentialMutation) ResetChallenge() {
	m.challenge = nil
	m.clearedchallenge = false
}

// Where appends a list predicates to the TotpCredentialMutation builder.
func (m *TotpCredentialMutation) Where(ps ...predicate.TotpCredential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TotpCredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TotpCredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TotpCredential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TotpCredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TotpCredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TotpCredential).
func (m *TotpCredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TotpCredentialMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.createdAt != nil {
		fields = append(fields, totpcredential.FieldCreatedAt)
	}
	if m.secret != nil {
		fields = append(fields, totpcredential.FieldSecret)
	}
	if m.validated != nil {
		fields = append(fields, totpcredential.FieldValidated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TotpCredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case totpcredential.FieldCreatedAt:
		return m.CreatedAt()
	case totpcredential.FieldSecret:
		return m.Secret()
	case totpcredential.FieldValidated:
		return m.Validated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TotpCredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case totpcredential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case totpcredential.FieldSecret:
		return m.OldSecret(ctx)
	case totpcredential.FieldValidated:
		return m.OldValidated(ctx)
	}
	return nil, fmt.Errorf("unknown TotpCredential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TotpCredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case totpcredential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case totpcredential.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case totpcredential.FieldValidated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidated(v)
		return nil
	}
	return fmt.Errorf("unknown TotpCredential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TotpCredentialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TotpCredentialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TotpCredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TotpCredential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TotpCredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TotpCredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TotpCredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TotpCredential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TotpCredentialMutation) ResetField(name string) error {
	switch name {
	case totpcredential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case totpcredential.FieldSecret:
		m.ResetSecret()
		return nil
	case totpcredential.FieldValidated:
		m.ResetValidated()
		return nil
	}
	return fmt.Errorf("unknown TotpCredential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TotpCredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, totpcredential.EdgeUser)
	}
	if m.challenge != nil {
		edges = append(edges, totpcredential.EdgeChallenge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TotpCredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case totpcredential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case totpcredential.EdgeChallenge:
		if id := m.challenge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TotpCredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TotpCredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TotpCredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, totpcredential.EdgeUser)
	}
	if m.clearedchallenge {
		edges = append(edges, totpcredential.EdgeChallenge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TotpCredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case totpcredential.EdgeUser:
		return m.cleareduser
	case totpcredential.EdgeChallenge:
		return m.clearedchallenge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TotpCredentialMutation) ClearEdge(name string) error {
	switch name {
	case totpcredential.EdgeUser:
		m.ClearUser()
		return nil
	case totpcredential.EdgeChallenge:
		m.ClearChallenge()
		return nil
	}
	return fmt.Errorf("unknown TotpCredential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TotpCredentialMutation) ResetEdge(name string) error {
	switch name {
	case totpcredential.EdgeUser:
		m.ResetUser()
		return nil
	case totpcredential.EdgeChallenge:
		m.ResetChallenge()
		return nil
	}
	return fmt.Errorf("unknown TotpCredential edge %s", name)
}

// URLMutation represents an operation that mutates the Url nodes in the graph.
type URLMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	url             *[]byte
	urlIv           *[]byte
	clearedFields   map[string]struct{}
	password        *uuid.UUID
	clearedpassword bool
	done            bool
	oldValue        func(context.Context) (*Url, error)
	predicates      []predicate.Url
}

var _ ent.Mutation = (*URLMutation)(nil)

// urlOption allows management of the mutation configuration using functional options.
type urlOption func(*URLMutation)

// newURLMutation creates new mutation for the Url entity.
func newURLMutation(c config, op Op, opts ...urlOption) *URLMutation {
	m := &URLMutation{
		config:        c,
		op:            op,
		typ:           TypeURL,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUrlID sets the ID field of the mutation.
func withUrlID(id uuid.UUID) urlOption {
	return func(m *URLMutation) {
		var (
			err   error
			once  sync.Once
			value *Url
		)
		m.oldValue = func(ctx context.Context) (*Url, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Url.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUrl sets the old Url of the mutation.
func withUrl(node *Url) urlOption {
	return func(m *URLMutation) {
		m.oldValue = func(context.Context) (*Url, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m URLMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m URLMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Url entities.
func (m *URLMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *URLMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *URLMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Url.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *URLMutation) SetURL(b []byte) {
	m.url = &b
}

// URL returns the value of the "url" field in the mutation.
func (m *URLMutation) URL() (r []byte, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Url entity.
// If the Url object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldURL(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *URLMutation) ResetURL() {
	m.url = nil
}

// SetUrlIv sets the "urlIv" field.
func (m *URLMutation) SetUrlIv(b []byte) {
	m.urlIv = &b
}

// UrlIv returns the value of the "urlIv" field in the mutation.
func (m *URLMutation) UrlIv() (r []byte, exists bool) {
	v := m.urlIv
	if v == nil {
		return
	}
	return *v, true
}

// OldUrlIv returns the old "urlIv" field's value of the Url entity.
// If the Url object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldUrlIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrlIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrlIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrlIv: %w", err)
	}
	return oldValue.UrlIv, nil
}

// ResetUrlIv resets all changes to the "urlIv" field.
func (m *URLMutation) ResetUrlIv() {
	m.urlIv = nil
}

// SetPasswordID sets the "password" edge to the Password entity by id.
func (m *URLMutation) SetPasswordID(id uuid.UUID) {
	m.password = &id
}

// ClearPassword clears the "password" edge to the Password entity.
func (m *URLMutation) ClearPassword() {
	m.clearedpassword = true
}

// PasswordCleared reports if the "password" edge to the Password entity was cleared.
func (m *URLMutation) PasswordCleared() bool {
	return m.clearedpassword
}

// PasswordID returns the "password" edge ID in the mutation.
func (m *URLMutation) PasswordID() (id uuid.UUID, exists bool) {
	if m.password != nil {
		return *m.password, true
	}
	return
}

// PasswordIDs returns the "password" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PasswordID instead. It exists only for internal usage by the builders.
func (m *URLMutation) PasswordIDs() (ids []uuid.UUID) {
	if id := m.password; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPassword resets all changes to the "password" edge.
func (m *URLMutation) ResetPassword() {
	m.password = nil
	m.clearedpassword = false
}

// Where appends a list predicates to the URLMutation builder.
func (m *URLMutation) Where(ps ...predicate.Url) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the URLMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *URLMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Url, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *URLMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *URLMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Url).
func (m *URLMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *URLMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.url != nil {
		fields = append(fields, url.FieldURL)
	}
	if m.urlIv != nil {
		fields = append(fields, url.FieldUrlIv)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *URLMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case url.FieldURL:
		return m.URL()
	case url.FieldUrlIv:
		return m.UrlIv()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *URLMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case url.FieldURL:
		return m.OldURL(ctx)
	case url.FieldUrlIv:
		return m.OldUrlIv(ctx)
	}
	return nil, fmt.Errorf("unknown Url field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLMutation) SetField(name string, value ent.Value) error {
	switch name {
	case url.FieldURL:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case url.FieldUrlIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrlIv(v)
		return nil
	}
	return fmt.Errorf("unknown Url field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *URLMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *URLMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Url numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *URLMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *URLMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *URLMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Url nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *URLMutation) ResetField(name string) error {
	switch name {
	case url.FieldURL:
		m.ResetURL()
		return nil
	case url.FieldUrlIv:
		m.ResetUrlIv()
		return nil
	}
	return fmt.Errorf("unknown Url field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *URLMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.password != nil {
		edges = append(edges, url.EdgePassword)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *URLMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case url.EdgePassword:
		if id := m.password; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *URLMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *URLMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *URLMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpassword {
		edges = append(edges, url.EdgePassword)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *URLMutation) EdgeCleared(name string) bool {
	switch name {
	case url.EdgePassword:
		return m.clearedpassword
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *URLMutation) ClearEdge(name string) error {
	switch name {
	case url.EdgePassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Url unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *URLMutation) ResetEdge(name string) error {
	switch name {
	case url.EdgePassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Url edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	email                             *string
	strengthenedMasterHash            *[]byte
	strengthenedMasterHashSalt        *[]byte
	protectedDatabaseKey              *[]byte
	protectedDatabaseKeyIv            *[]byte
	webauthnEnabled                   *bool
	totpEnabled                       *bool
	verified                          *bool
	clearedFields                     map[string]struct{}
	totpCredential                    *uuid.UUID
	clearedtotpCredential             bool
	webauthnCredentials               map[uuid.UUID]struct{}
	removedwebauthnCredentials        map[uuid.UUID]struct{}
	clearedwebauthnCredentials        bool
	webauthnRegisterChallenges        map[uuid.UUID]struct{}
	removedwebauthnRegisterChallenges map[uuid.UUID]struct{}
	clearedwebauthnRegisterChallenges bool
	vaults                            map[uuid.UUID]struct{}
	removedvaults                     map[uuid.UUID]struct{}
	clearedvaults                     bool
	sessions                          map[uuid.UUID]struct{}
	removedsessions                   map[uuid.UUID]struct{}
	clearedsessions                   bool
	challenges                        map[uuid.UUID]struct{}
	removedchallenges                 map[uuid.UUID]struct{}
	clearedchallenges                 bool
	done                              bool
	oldValue                          func(context.Context) (*User, error)
	predicates                        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStrengthenedMasterHash sets the "strengthenedMasterHash" field.
func (m *UserMutation) SetStrengthenedMasterHash(b []byte) {
	m.strengthenedMasterHash = &b
}

// StrengthenedMasterHash returns the value of the "strengthenedMasterHash" field in the mutation.
func (m *UserMutation) StrengthenedMasterHash() (r []byte, exists bool) {
	v := m.strengthenedMasterHash
	if v == nil {
		return
	}
	return *v, true
}

// OldStrengthenedMasterHash returns the old "strengthenedMasterHash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStrengthenedMasterHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrengthenedMasterHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrengthenedMasterHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrengthenedMasterHash: %w", err)
	}
	return oldValue.StrengthenedMasterHash, nil
}

// ResetStrengthenedMasterHash resets all changes to the "strengthenedMasterHash" field.
func (m *UserMutation) ResetStrengthenedMasterHash() {
	m.strengthenedMasterHash = nil
}

// SetStrengthenedMasterHashSalt sets the "strengthenedMasterHashSalt" field.
func (m *UserMutation) SetStrengthenedMasterHashSalt(b []byte) {
	m.strengthenedMasterHashSalt = &b
}

// StrengthenedMasterHashSalt returns the value of the "strengthenedMasterHashSalt" field in the mutation.
func (m *UserMutation) StrengthenedMasterHashSalt() (r []byte, exists bool) {
	v := m.strengthenedMasterHashSalt
	if v == nil {
		return
	}
	return *v, true
}

// OldStrengthenedMasterHashSalt returns the old "strengthenedMasterHashSalt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStrengthenedMasterHashSalt(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrengthenedMasterHashSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrengthenedMasterHashSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrengthenedMasterHashSalt: %w", err)
	}
	return oldValue.StrengthenedMasterHashSalt, nil
}

// ResetStrengthenedMasterHashSalt resets all changes to the "strengthenedMasterHashSalt" field.
func (m *UserMutation) ResetStrengthenedMasterHashSalt() {
	m.strengthenedMasterHashSalt = nil
}

// SetProtectedDatabaseKey sets the "protectedDatabaseKey" field.
func (m *UserMutation) SetProtectedDatabaseKey(b []byte) {
	m.protectedDatabaseKey = &b
}

// ProtectedDatabaseKey returns the value of the "protectedDatabaseKey" field in the mutation.
func (m *UserMutation) ProtectedDatabaseKey() (r []byte, exists bool) {
	v := m.protectedDatabaseKey
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedDatabaseKey returns the old "protectedDatabaseKey" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProtectedDatabaseKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedDatabaseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedDatabaseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedDatabaseKey: %w", err)
	}
	return oldValue.ProtectedDatabaseKey, nil
}

// ResetProtectedDatabaseKey resets all changes to the "protectedDatabaseKey" field.
func (m *UserMutation) ResetProtectedDatabaseKey() {
	m.protectedDatabaseKey = nil
}

// SetProtectedDatabaseKeyIv sets the "protectedDatabaseKeyIv" field.
func (m *UserMutation) SetProtectedDatabaseKeyIv(b []byte) {
	m.protectedDatabaseKeyIv = &b
}

// ProtectedDatabaseKeyIv returns the value of the "protectedDatabaseKeyIv" field in the mutation.
func (m *UserMutation) ProtectedDatabaseKeyIv() (r []byte, exists bool) {
	v := m.protectedDatabaseKeyIv
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedDatabaseKeyIv returns the old "protectedDatabaseKeyIv" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProtectedDatabaseKeyIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedDatabaseKeyIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedDatabaseKeyIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedDatabaseKeyIv: %w", err)
	}
	return oldValue.ProtectedDatabaseKeyIv, nil
}

// ResetProtectedDatabaseKeyIv resets all changes to the "protectedDatabaseKeyIv" field.
func (m *UserMutation) ResetProtectedDatabaseKeyIv() {
	m.protectedDatabaseKeyIv = nil
}

// SetWebauthnEnabled sets the "webauthnEnabled" field.
func (m *UserMutation) SetWebauthnEnabled(b bool) {
	m.webauthnEnabled = &b
}

// WebauthnEnabled returns the value of the "webauthnEnabled" field in the mutation.
func (m *UserMutation) WebauthnEnabled() (r bool, exists bool) {
	v := m.webauthnEnabled
	if v == nil {
		return
	}
	return *v, true
}

// OldWebauthnEnabled returns the old "webauthnEnabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWebauthnEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebauthnEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebauthnEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebauthnEnabled: %w", err)
	}
	return oldValue.WebauthnEnabled, nil
}

// ResetWebauthnEnabled resets all changes to the "webauthnEnabled" field.
func (m *UserMutation) ResetWebauthnEnabled() {
	m.webauthnEnabled = nil
}

// SetTotpEnabled sets the "totpEnabled" field.
func (m *UserMutation) SetTotpEnabled(b bool) {
	m.totpEnabled = &b
}

// TotpEnabled returns the value of the "totpEnabled" field in the mutation.
func (m *UserMutation) TotpEnabled() (r bool, exists bool) {
	v := m.totpEnabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabled returns the old "totpEnabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabled: %w", err)
	}
	return oldValue.TotpEnabled, nil
}

// ResetTotpEnabled resets all changes to the "totpEnabled" field.
func (m *UserMutation) ResetTotpEnabled() {
	m.totpEnabled = nil
}

// SetVerified sets the "verified" field.
func (m *UserMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *UserMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *UserMutation) ResetVerified() {
	m.verified = nil
}

// SetTotpCredentialID sets the "totpCredential" edge to the TotpCredential entity by id.
func (m *UserMutation) SetTotpCredentialID(id uuid.UUID) {
	m.totpCredential = &id
}

// ClearTotpCredential clears the "totpCredential" edge to the TotpCredential entity.
func (m *UserMutation) ClearTotpCredential() {
	m.clearedtotpCredential = true
}

// TotpCredentialCleared reports if the "totpCredential" edge to the TotpCredential entity was cleared.
func (m *UserMutation) TotpCredentialCleared() bool {
	return m.clearedtotpCredential
}

// TotpCredentialID returns the "totpCredential" edge ID in the mutation.
func (m *UserMutation) TotpCredentialID() (id uuid.UUID, exists bool) {
	if m.totpCredential != nil {
		return *m.totpCredential, true
	}
	return
}

// TotpCredentialIDs returns the "totpCredential" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TotpCredentialID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TotpCredentialIDs() (ids []uuid.UUID) {
	if id := m.totpCredential; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTotpCredential resets all changes to the "totpCredential" edge.
func (m *UserMutation) ResetTotpCredential() {
	m.totpCredential = nil
	m.clearedtotpCredential = false
}

// AddWebauthnCredentialIDs adds the "webauthnCredentials" edge to the WebAuthnCredential entity by ids.
func (m *UserMutation) AddWebauthnCredentialIDs(ids ...uuid.UUID) {
	if m.webauthnCredentials == nil {
		m.webauthnCredentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.webauthnCredentials[ids[i]] = struct{}{}
	}
}

// ClearWebauthnCredentials clears the "webauthnCredentials" edge to the WebAuthnCredential entity.
func (m *UserMutation) ClearWebauthnCredentials() {
	m.clearedwebauthnCredentials = true
}

// WebauthnCredentialsCleared reports if the "webauthnCredentials" edge to the WebAuthnCredential entity was cleared.
func (m *UserMutation) WebauthnCredentialsCleared() bool {
	return m.clearedwebauthnCredentials
}

// RemoveWebauthnCredentialIDs removes the "webauthnCredentials" edge to the WebAuthnCredential entity by IDs.
func (m *UserMutation) RemoveWebauthnCredentialIDs(ids ...uuid.UUID) {
	if m.removedwebauthnCredentials == nil {
		m.removedwebauthnCredentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.webauthnCredentials, ids[i])
		m.removedwebauthnCredentials[ids[i]] = struct{}{}
	}
}

// RemovedWebauthnCredentials returns the removed IDs of the "webauthnCredentials" edge to the WebAuthnCredential entity.
func (m *UserMutation) RemovedWebauthnCredentialsIDs() (ids []uuid.UUID) {
	for id := range m.removedwebauthnCredentials {
		ids = append(ids, id)
	}
	return
}

// WebauthnCredentialsIDs returns the "webauthnCredentials" edge IDs in the mutation.
func (m *UserMutation) WebauthnCredentialsIDs() (ids []uuid.UUID) {
	for id := range m.webauthnCredentials {
		ids = append(ids, id)
	}
	return
}

// ResetWebauthnCredentials resets all changes to the "webauthnCredentials" edge.
func (m *UserMutation) ResetWebauthnCredentials() {
	m.webauthnCredentials = nil
	m.clearedwebauthnCredentials = false
	m.removedwebauthnCredentials = nil
}

// AddWebauthnRegisterChallengeIDs adds the "webauthnRegisterChallenges" edge to the WebAuthnRegisterChallenge entity by ids.
func (m *UserMutation) AddWebauthnRegisterChallengeIDs(ids ...uuid.UUID) {
	if m.webauthnRegisterChallenges == nil {
		m.webauthnRegisterChallenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.webauthnRegisterChallenges[ids[i]] = struct{}{}
	}
}

// ClearWebauthnRegisterChallenges clears the "webauthnRegisterChallenges" edge to the WebAuthnRegisterChallenge entity.
func (m *UserMutation) ClearWebauthnRegisterChallenges() {
	m.clearedwebauthnRegisterChallenges = true
}

// WebauthnRegisterChallengesCleared reports if the "webauthnRegisterChallenges" edge to the WebAuthnRegisterChallenge entity was cleared.
func (m *UserMutation) WebauthnRegisterChallengesCleared() bool {
	return m.clearedwebauthnRegisterChallenges
}

// RemoveWebauthnRegisterChallengeIDs removes the "webauthnRegisterChallenges" edge to the WebAuthnRegisterChallenge entity by IDs.
func (m *UserMutation) RemoveWebauthnRegisterChallengeIDs(ids ...uuid.UUID) {
	if m.removedwebauthnRegisterChallenges == nil {
		m.removedwebauthnRegisterChallenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.webauthnRegisterChallenges, ids[i])
		m.removedwebauthnRegisterChallenges[ids[i]] = struct{}{}
	}
}

// RemovedWebauthnRegisterChallenges returns the removed IDs of the "webauthnRegisterChallenges" edge to the WebAuthnRegisterChallenge entity.
func (m *UserMutation) RemovedWebauthnRegisterChallengesIDs() (ids []uuid.UUID) {
	for id := range m.removedwebauthnRegisterChallenges {
		ids = append(ids, id)
	}
	return
}

// WebauthnRegisterChallengesIDs returns the "webauthnRegisterChallenges" edge IDs in the mutation.
func (m *UserMutation) WebauthnRegisterChallengesIDs() (ids []uuid.UUID) {
	for id := range m.webauthnRegisterChallenges {
		ids = append(ids, id)
	}
	return
}

// ResetWebauthnRegisterChallenges resets all changes to the "webauthnRegisterChallenges" edge.
func (m *UserMutation) ResetWebauthnRegisterChallenges() {
	m.webauthnRegisterChallenges = nil
	m.clearedwebauthnRegisterChallenges = false
	m.removedwebauthnRegisterChallenges = nil
}

// AddVaultIDs adds the "vaults" edge to the Vault entity by ids.
func (m *UserMutation) AddVaultIDs(ids ...uuid.UUID) {
	if m.vaults == nil {
		m.vaults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vaults[ids[i]] = struct{}{}
	}
}

// ClearVaults clears the "vaults" edge to the Vault entity.
func (m *UserMutation) ClearVaults() {
	m.clearedvaults = true
}

// VaultsCleared reports if the "vaults" edge to the Vault entity was cleared.
func (m *UserMutation) VaultsCleared() bool {
	return m.clearedvaults
}

// RemoveVaultIDs removes the "vaults" edge to the Vault entity by IDs.
func (m *UserMutation) RemoveVaultIDs(ids ...uuid.UUID) {
	if m.removedvaults == nil {
		m.removedvaults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vaults, ids[i])
		m.removedvaults[ids[i]] = struct{}{}
	}
}

// RemovedVaults returns the removed IDs of the "vaults" edge to the Vault entity.
func (m *UserMutation) RemovedVaultsIDs() (ids []uuid.UUID) {
	for id := range m.removedvaults {
		ids = append(ids, id)
	}
	return
}

// VaultsIDs returns the "vaults" edge IDs in the mutation.
func (m *UserMutation) VaultsIDs() (ids []uuid.UUID) {
	for id := range m.vaults {
		ids = append(ids, id)
	}
	return
}

// ResetVaults resets all changes to the "vaults" edge.
func (m *UserMutation) ResetVaults() {
	m.vaults = nil
	m.clearedvaults = false
	m.removedvaults = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddChallengeIDs adds the "challenges" edge to the Challenge entity by ids.
func (m *UserMutation) AddChallengeIDs(ids ...uuid.UUID) {
	if m.challenges == nil {
		m.challenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.challenges[ids[i]] = struct{}{}
	}
}

// ClearChallenges clears the "challenges" edge to the Challenge entity.
func (m *UserMutation) ClearChallenges() {
	m.clearedchallenges = true
}

// ChallengesCleared reports if the "challenges" edge to the Challenge entity was cleared.
func (m *UserMutation) ChallengesCleared() bool {
	return m.clearedchallenges
}

// RemoveChallengeIDs removes the "challenges" edge to the Challenge entity by IDs.
func (m *UserMutation) RemoveChallengeIDs(ids ...uuid.UUID) {
	if m.removedchallenges == nil {
		m.removedchallenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.challenges, ids[i])
		m.removedchallenges[ids[i]] = struct{}{}
	}
}

// RemovedChallenges returns the removed IDs of the "challenges" edge to the Challenge entity.
func (m *UserMutation) RemovedChallengesIDs() (ids []uuid.UUID) {
	for id := range m.removedchallenges {
		ids = append(ids, id)
	}
	return
}

// ChallengesIDs returns the "challenges" edge IDs in the mutation.
func (m *UserMutation) ChallengesIDs() (ids []uuid.UUID) {
	for id := range m.challenges {
		ids = append(ids, id)
	}
	return
}

// ResetChallenges resets all changes to the "challenges" edge.
func (m *UserMutation) ResetChallenges() {
	m.challenges = nil
	m.clearedchallenges = false
	m.removedchallenges = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.strengthenedMasterHash != nil {
		fields = append(fields, user.FieldStrengthenedMasterHash)
	}
	if m.strengthenedMasterHashSalt != nil {
		fields = append(fields, user.FieldStrengthenedMasterHashSalt)
	}
	if m.protectedDatabaseKey != nil {
		fields = append(fields, user.FieldProtectedDatabaseKey)
	}
	if m.protectedDatabaseKeyIv != nil {
		fields = append(fields, user.FieldProtectedDatabaseKeyIv)
	}
	if m.webauthnEnabled != nil {
		fields = append(fields, user.FieldWebauthnEnabled)
	}
	if m.totpEnabled != nil {
		fields = append(fields, user.FieldTotpEnabled)
	}
	if m.verified != nil {
		fields = append(fields, user.FieldVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldStrengthenedMasterHash:
		return m.StrengthenedMasterHash()
	case user.FieldStrengthenedMasterHashSalt:
		return m.StrengthenedMasterHashSalt()
	case user.FieldProtectedDatabaseKey:
		return m.ProtectedDatabaseKey()
	case user.FieldProtectedDatabaseKeyIv:
		return m.ProtectedDatabaseKeyIv()
	case user.FieldWebauthnEnabled:
		return m.WebauthnEnabled()
	case user.FieldTotpEnabled:
		return m.TotpEnabled()
	case user.FieldVerified:
		return m.Verified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStrengthenedMasterHash:
		return m.OldStrengthenedMasterHash(ctx)
	case user.FieldStrengthenedMasterHashSalt:
		return m.OldStrengthenedMasterHashSalt(ctx)
	case user.FieldProtectedDatabaseKey:
		return m.OldProtectedDatabaseKey(ctx)
	case user.FieldProtectedDatabaseKeyIv:
		return m.OldProtectedDatabaseKeyIv(ctx)
	case user.FieldWebauthnEnabled:
		return m.OldWebauthnEnabled(ctx)
	case user.FieldTotpEnabled:
		return m.OldTotpEnabled(ctx)
	case user.FieldVerified:
		return m.OldVerified(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStrengthenedMasterHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrengthenedMasterHash(v)
		return nil
	case user.FieldStrengthenedMasterHashSalt:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrengthenedMasterHashSalt(v)
		return nil
	case user.FieldProtectedDatabaseKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedDatabaseKey(v)
		return nil
	case user.FieldProtectedDatabaseKeyIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedDatabaseKeyIv(v)
		return nil
	case user.FieldWebauthnEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebauthnEnabled(v)
		return nil
	case user.FieldTotpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabled(v)
		return nil
	case user.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStrengthenedMasterHash:
		m.ResetStrengthenedMasterHash()
		return nil
	case user.FieldStrengthenedMasterHashSalt:
		m.ResetStrengthenedMasterHashSalt()
		return nil
	case user.FieldProtectedDatabaseKey:
		m.ResetProtectedDatabaseKey()
		return nil
	case user.FieldProtectedDatabaseKeyIv:
		m.ResetProtectedDatabaseKeyIv()
		return nil
	case user.FieldWebauthnEnabled:
		m.ResetWebauthnEnabled()
		return nil
	case user.FieldTotpEnabled:
		m.ResetTotpEnabled()
		return nil
	case user.FieldVerified:
		m.ResetVerified()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.totpCredential != nil {
		edges = append(edges, user.EdgeTotpCredential)
	}
	if m.webauthnCredentials != nil {
		edges = append(edges, user.EdgeWebauthnCredentials)
	}
	if m.webauthnRegisterChallenges != nil {
		edges = append(edges, user.EdgeWebauthnRegisterChallenges)
	}
	if m.vaults != nil {
		edges = append(edges, user.EdgeVaults)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.challenges != nil {
		edges = append(edges, user.EdgeChallenges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTotpCredential:
		if id := m.totpCredential; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeWebauthnCredentials:
		ids := make([]ent.Value, 0, len(m.webauthnCredentials))
		for id := range m.webauthnCredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthnRegisterChallenges:
		ids := make([]ent.Value, 0, len(m.webauthnRegisterChallenges))
		for id := range m.webauthnRegisterChallenges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVaults:
		ids := make([]ent.Value, 0, len(m.vaults))
		for id := range m.vaults {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChallenges:
		ids := make([]ent.Value, 0, len(m.challenges))
		for id := range m.challenges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedwebauthnCredentials != nil {
		edges = append(edges, user.EdgeWebauthnCredentials)
	}
	if m.removedwebauthnRegisterChallenges != nil {
		edges = append(edges, user.EdgeWebauthnRegisterChallenges)
	}
	if m.removedvaults != nil {
		edges = append(edges, user.EdgeVaults)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedchallenges != nil {
		edges = append(edges, user.EdgeChallenges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeWebauthnCredentials:
		ids := make([]ent.Value, 0, len(m.removedwebauthnCredentials))
		for id := range m.removedwebauthnCredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthnRegisterChallenges:
		ids := make([]ent.Value, 0, len(m.removedwebauthnRegisterChallenges))
		for id := range m.removedwebauthnRegisterChallenges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVaults:
		ids := make([]ent.Value, 0, len(m.removedvaults))
		for id := range m.removedvaults {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChallenges:
		ids := make([]ent.Value, 0, len(m.removedchallenges))
		for id := range m.removedchallenges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtotpCredential {
		edges = append(edges, user.EdgeTotpCredential)
	}
	if m.clearedwebauthnCredentials {
		edges = append(edges, user.EdgeWebauthnCredentials)
	}
	if m.clearedwebauthnRegisterChallenges {
		edges = append(edges, user.EdgeWebauthnRegisterChallenges)
	}
	if m.clearedvaults {
		edges = append(edges, user.EdgeVaults)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedchallenges {
		edges = append(edges, user.EdgeChallenges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTotpCredential:
		return m.clearedtotpCredential
	case user.EdgeWebauthnCredentials:
		return m.clearedwebauthnCredentials
	case user.EdgeWebauthnRegisterChallenges:
		return m.clearedwebauthnRegisterChallenges
	case user.EdgeVaults:
		return m.clearedvaults
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeChallenges:
		return m.clearedchallenges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTotpCredential:
		m.ClearTotpCredential()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTotpCredential:
		m.ResetTotpCredential()
		return nil
	case user.EdgeWebauthnCredentials:
		m.ResetWebauthnCredentials()
		return nil
	case user.EdgeWebauthnRegisterChallenges:
		m.ResetWebauthnRegisterChallenges()
		return nil
	case user.EdgeVaults:
		m.ResetVaults()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeChallenges:
		m.ResetChallenges()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VaultMutation represents an operation that mutates the Vault nodes in the graph.
type VaultMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	createdAt        *time.Time
	name             *string
	colour           *string
	clearedFields    map[string]struct{}
	passwords        map[uuid.UUID]struct{}
	removedpasswords map[uuid.UUID]struct{}
	clearedpasswords bool
	user             *uuid.UUID
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Vault, error)
	predicates       []predicate.Vault
}

var _ ent.Mutation = (*VaultMutation)(nil)

// vaultOption allows management of the mutation configuration using functional options.
type vaultOption func(*VaultMutation)

// newVaultMutation creates new mutation for the Vault entity.
func newVaultMutation(c config, op Op, opts ...vaultOption) *VaultMutation {
	m := &VaultMutation{
		config:        c,
		op:            op,
		typ:           TypeVault,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultID sets the ID field of the mutation.
func withVaultID(id uuid.UUID) vaultOption {
	return func(m *VaultMutation) {
		var (
			err   error
			once  sync.Once
			value *Vault
		)
		m.oldValue = func(ctx context.Context) (*Vault, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vault.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVault sets the old Vault of the mutation.
func withVault(node *Vault) vaultOption {
	return func(m *VaultMutation) {
		m.oldValue = func(context.Context) (*Vault, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vault entities.
func (m *VaultMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vault.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *VaultMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *VaultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *VaultMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetName sets the "name" field.
func (m *VaultMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VaultMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VaultMutation) ResetName() {
	m.name = nil
}

// SetColour sets the "colour" field.
func (m *VaultMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *VaultMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ResetColour resets all changes to the "colour" field.
func (m *VaultMutation) ResetColour() {
	m.colour = nil
}

// AddPasswordIDs adds the "passwords" edge to the Password entity by ids.
func (m *VaultMutation) AddPasswordIDs(ids ...uuid.UUID) {
	if m.passwords == nil {
		m.passwords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.passwords[ids[i]] = struct{}{}
	}
}

// ClearPasswords clears the "passwords" edge to the Password entity.
func (m *VaultMutation) ClearPasswords() {
	m.clearedpasswords = true
}

// PasswordsCleared reports if the "passwords" edge to the Password entity was cleared.
func (m *VaultMutation) PasswordsCleared() bool {
	return m.clearedpasswords
}

// RemovePasswordIDs removes the "passwords" edge to the Password entity by IDs.
func (m *VaultMutation) RemovePasswordIDs(ids ...uuid.UUID) {
	if m.removedpasswords == nil {
		m.removedpasswords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.passwords, ids[i])
		m.removedpasswords[ids[i]] = struct{}{}
	}
}

// RemovedPasswords returns the removed IDs of the "passwords" edge to the Password entity.
func (m *VaultMutation) RemovedPasswordsIDs() (ids []uuid.UUID) {
	for id := range m.removedpasswords {
		ids = append(ids, id)
	}
	return
}

// PasswordsIDs returns the "passwords" edge IDs in the mutation.
func (m *VaultMutation) PasswordsIDs() (ids []uuid.UUID) {
	for id := range m.passwords {
		ids = append(ids, id)
	}
	return
}

// ResetPasswords resets all changes to the "passwords" edge.
func (m *VaultMutation) ResetPasswords() {
	m.passwords = nil
	m.clearedpasswords = false
	m.removedpasswords = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VaultMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VaultMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VaultMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VaultMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VaultMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VaultMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VaultMutation builder.
func (m *VaultMutation) Where(ps ...predicate.Vault) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vault, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vault).
func (m *VaultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.createdAt != nil {
		fields = append(fields, vault.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, vault.FieldName)
	}
	if m.colour != nil {
		fields = append(fields, vault.FieldColour)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vault.FieldCreatedAt:
		return m.CreatedAt()
	case vault.FieldName:
		return m.Name()
	case vault.FieldColour:
		return m.Colour()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vault.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vault.FieldName:
		return m.OldName(ctx)
	case vault.FieldColour:
		return m.OldColour(ctx)
	}
	return nil, fmt.Errorf("unknown Vault field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vault.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vault.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vault.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	}
	return fmt.Errorf("unknown Vault field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vault numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vault nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultMutation) ResetField(name string) error {
	switch name {
	case vault.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vault.FieldName:
		m.ResetName()
		return nil
	case vault.FieldColour:
		m.ResetColour()
		return nil
	}
	return fmt.Errorf("unknown Vault field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.passwords != nil {
		edges = append(edges, vault.EdgePasswords)
	}
	if m.user != nil {
		edges = append(edges, vault.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vault.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.passwords))
		for id := range m.passwords {
			ids = append(ids, id)
		}
		return ids
	case vault.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpasswords != nil {
		edges = append(edges, vault.EdgePasswords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vault.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.removedpasswords))
		for id := range m.removedpasswords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpasswords {
		edges = append(edges, vault.EdgePasswords)
	}
	if m.cleareduser {
		edges = append(edges, vault.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultMutation) EdgeCleared(name string) bool {
	switch name {
	case vault.EdgePasswords:
		return m.clearedpasswords
	case vault.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultMutation) ClearEdge(name string) error {
	switch name {
	case vault.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Vault unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultMutation) ResetEdge(name string) error {
	switch name {
	case vault.EdgePasswords:
		m.ResetPasswords()
		return nil
	case vault.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Vault edge %s", name)
}

// WebAuthnChallengeMutation represents an operation that mutates the WebAuthnChallenge nodes in the graph.
type WebAuthnChallengeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	sdChallenge                *string
	userId                     *[]byte
	allowedCredentialIds       *[][]uint8
	appendallowedCredentialIds [][]uint8
	userVerification           *string
	extensions                 *map[string]interface{}
	clearedFields              map[string]struct{}
	challenge                  *uuid.UUID
	clearedchallenge           bool
	done                       bool
	oldValue                   func(context.Context) (*WebAuthnChallenge, error)
	predicates                 []predicate.WebAuthnChallenge
}

var _ ent.Mutation = (*WebAuthnChallengeMutation)(nil)

// webauthnchallengeOption allows management of the mutation configuration using functional options.
type webauthnchallengeOption func(*WebAuthnChallengeMutation)

// newWebAuthnChallengeMutation creates new mutation for the WebAuthnChallenge entity.
func newWebAuthnChallengeMutation(c config, op Op, opts ...webauthnchallengeOption) *WebAuthnChallengeMutation {
	m := &WebAuthnChallengeMutation{
		config:        c,
		op:            op,
		typ:           TypeWebAuthnChallenge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebAuthnChallengeID sets the ID field of the mutation.
func withWebAuthnChallengeID(id uuid.UUID) webauthnchallengeOption {
	return func(m *WebAuthnChallengeMutation) {
		var (
			err   error
			once  sync.Once
			value *WebAuthnChallenge
		)
		m.oldValue = func(ctx context.Context) (*WebAuthnChallenge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebAuthnChallenge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebAuthnChallenge sets the old WebAuthnChallenge of the mutation.
func withWebAuthnChallenge(node *WebAuthnChallenge) webauthnchallengeOption {
	return func(m *WebAuthnChallengeMutation) {
		m.oldValue = func(context.Context) (*WebAuthnChallenge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebAuthnChallengeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebAuthnChallengeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebAuthnChallenge entities.
func (m *WebAuthnChallengeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebAuthnChallengeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebAuthnChallengeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebAuthnChallenge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSdChallenge sets the "sdChallenge" field.
func (m *WebAuthnChallengeMutation) SetSdChallenge(s string) {
	m.sdChallenge = &s
}

// SdChallenge returns the value of the "sdChallenge" field in the mutation.
func (m *WebAuthnChallengeMutation) SdChallenge() (r string, exists bool) {
	v := m.sdChallenge
	if v == nil {
		return
	}
	return *v, true
}

// OldSdChallenge returns the old "sdChallenge" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldSdChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSdChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSdChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSdChallenge: %w", err)
	}
	return oldValue.SdChallenge, nil
}

// ClearSdChallenge clears the value of the "sdChallenge" field.
func (m *WebAuthnChallengeMutation) ClearSdChallenge() {
	m.sdChallenge = nil
	m.clearedFields[webauthnchallenge.FieldSdChallenge] = struct{}{}
}

// SdChallengeCleared returns if the "sdChallenge" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) SdChallengeCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldSdChallenge]
	return ok
}

// ResetSdChallenge resets all changes to the "sdChallenge" field.
func (m *WebAuthnChallengeMutation) ResetSdChallenge() {
	m.sdChallenge = nil
	delete(m.clearedFields, webauthnchallenge.FieldSdChallenge)
}

// SetUserId sets the "userId" field.
func (m *WebAuthnChallengeMutation) SetUserId(b []byte) {
	m.userId = &b
}

// UserId returns the value of the "userId" field in the mutation.
func (m *WebAuthnChallengeMutation) UserId() (r []byte, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldUserId(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "userId" field.
func (m *WebAuthnChallengeMutation) ClearUserId() {
	m.userId = nil
	m.clearedFields[webauthnchallenge.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *WebAuthnChallengeMutation) ResetUserId() {
	m.userId = nil
	delete(m.clearedFields, webauthnchallenge.FieldUserId)
}

// SetAllowedCredentialIds sets the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) SetAllowedCredentialIds(u [][]uint8) {
	m.allowedCredentialIds = &u
	m.appendallowedCredentialIds = nil
}

// AllowedCredentialIds returns the value of the "allowedCredentialIds" field in the mutation.
func (m *WebAuthnChallengeMutation) AllowedCredentialIds() (r [][]uint8, exists bool) {
	v := m.allowedCredentialIds
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedCredentialIds returns the old "allowedCredentialIds" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldAllowedCredentialIds(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedCredentialIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedCredentialIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedCredentialIds: %w", err)
	}
	return oldValue.AllowedCredentialIds, nil
}

// AppendAllowedCredentialIds adds u to the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) AppendAllowedCredentialIds(u [][]uint8) {
	m.appendallowedCredentialIds = append(m.appendallowedCredentialIds, u...)
}

// AppendedAllowedCredentialIds returns the list of values that were appended to the "allowedCredentialIds" field in this mutation.
func (m *WebAuthnChallengeMutation) AppendedAllowedCredentialIds() ([][]uint8, bool) {
	if len(m.appendallowedCredentialIds) == 0 {
		return nil, false
	}
	return m.appendallowedCredentialIds, true
}

// ClearAllowedCredentialIds clears the value of the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) ClearAllowedCredentialIds() {
	m.allowedCredentialIds = nil
	m.appendallowedCredentialIds = nil
	m.clearedFields[webauthnchallenge.FieldAllowedCredentialIds] = struct{}{}
}

// AllowedCredentialIdsCleared returns if the "allowedCredentialIds" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) AllowedCredentialIdsCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldAllowedCredentialIds]
	return ok
}

// ResetAllowedCredentialIds resets all changes to the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) ResetAllowedCredentialIds() {
	m.allowedCredentialIds = nil
	m.appendallowedCredentialIds = nil
	delete(m.clearedFields, webauthnchallenge.FieldAllowedCredentialIds)
}

// SetUserVerification sets the "userVerification" field.
func (m *WebAuthnChallengeMutation) SetUserVerification(s string) {
	m.userVerification = &s
}

// UserVerification returns the value of the "userVerification" field in the mutation.
func (m *WebAuthnChallengeMutation) UserVerification() (r string, exists bool) {
	v := m.userVerification
	if v == nil {
		return
	}
	return *v, true
}

// OldUserVerification returns the old "userVerification" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldUserVerification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserVerification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserVerification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserVerification: %w", err)
	}
	return oldValue.UserVerification, nil
}

// ClearUserVerification clears the value of the "userVerification" field.
func (m *WebAuthnChallengeMutation) ClearUserVerification() {
	m.userVerification = nil
	m.clearedFields[webauthnchallenge.FieldUserVerification] = struct{}{}
}

// UserVerificationCleared returns if the "userVerification" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) UserVerificationCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldUserVerification]
	return ok
}

// ResetUserVerification resets all changes to the "userVerification" field.
func (m *WebAuthnChallengeMutation) ResetUserVerification() {
	m.userVerification = nil
	delete(m.clearedFields, webauthnchallenge.FieldUserVerification)
}

// SetExtensions sets the "extensions" field.
func (m *WebAuthnChallengeMutation) SetExtensions(value map[string]interface{}) {
	m.extensions = &value
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *WebAuthnChallengeMutation) Extensions() (r map[string]interface{}, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldExtensions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ClearExtensions clears the value of the "extensions" field.
func (m *WebAuthnChallengeMutation) ClearExtensions() {
	m.extensions = nil
	m.clearedFields[webauthnchallenge.FieldExtensions] = struct{}{}
}

// ExtensionsCleared returns if the "extensions" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) ExtensionsCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldExtensions]
	return ok
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *WebAuthnChallengeMutation) ResetExtensions() {
	m.extensions = nil
	delete(m.clearedFields, webauthnchallenge.FieldExtensions)
}

// SetChallengeID sets the "challenge" edge to the Challenge entity by id.
func (m *WebAuthnChallengeMutation) SetChallengeID(id uuid.UUID) {
	m.challenge = &id
}

// ClearChallenge clears the "challenge" edge to the Challenge entity.
func (m *WebAuthnChallengeMutation) ClearChallenge() {
	m.clearedchallenge = true
}

// ChallengeCleared reports if the "challenge" edge to the Challenge entity was cleared.
func (m *WebAuthnChallengeMutation) ChallengeCleared() bool {
	return m.clearedchallenge
}

// ChallengeID returns the "challenge" edge ID in the mutation.
func (m *WebAuthnChallengeMutation) ChallengeID() (id uuid.UUID, exists bool) {
	if m.challenge != nil {
		return *m.challenge, true
	}
	return
}

// ChallengeIDs returns the "challenge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChallengeID instead. It exists only for internal usage by the builders.
func (m *WebAuthnChallengeMutation) ChallengeIDs() (ids []uuid.UUID) {
	if id := m.challenge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChallenge resets all changes to the "challenge" edge.
func (m *WebAuthnChallengeMutation) ResetChallenge() {
	m.challenge = nil
	m.clearedchallenge = false
}

// Where appends a list predicates to the WebAuthnChallengeMutation builder.
func (m *WebAuthnChallengeMutation) Where(ps ...predicate.WebAuthnChallenge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebAuthnChallengeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebAuthnChallengeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebAuthnChallenge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebAuthnChallengeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebAuthnChallengeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebAuthnChallenge).
func (m *WebAuthnChallengeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebAuthnChallengeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sdChallenge != nil {
		fields = append(fields, webauthnchallenge.FieldSdChallenge)
	}
	if m.userId != nil {
		fields = append(fields, webauthnchallenge.FieldUserId)
	}
	if m.allowedCredentialIds != nil {
		fields = append(fields, webauthnchallenge.FieldAllowedCredentialIds)
	}
	if m.userVerification != nil {
		fields = append(fields, webauthnchallenge.FieldUserVerification)
	}
	if m.extensions != nil {
		fields = append(fields, webauthnchallenge.FieldExtensions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebAuthnChallengeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webauthnchallenge.FieldSdChallenge:
		return m.SdChallenge()
	case webauthnchallenge.FieldUserId:
		return m.UserId()
	case webauthnchallenge.FieldAllowedCredentialIds:
		return m.AllowedCredentialIds()
	case webauthnchallenge.FieldUserVerification:
		return m.UserVerification()
	case webauthnchallenge.FieldExtensions:
		return m.Extensions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebAuthnChallengeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webauthnchallenge.FieldSdChallenge:
		return m.OldSdChallenge(ctx)
	case webauthnchallenge.FieldUserId:
		return m.OldUserId(ctx)
	case webauthnchallenge.FieldAllowedCredentialIds:
		return m.OldAllowedCredentialIds(ctx)
	case webauthnchallenge.FieldUserVerification:
		return m.OldUserVerification(ctx)
	case webauthnchallenge.FieldExtensions:
		return m.OldExtensions(ctx)
	}
	return nil, fmt.Errorf("unknown WebAuthnChallenge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnChallengeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webauthnchallenge.FieldSdChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSdChallenge(v)
		return nil
	case webauthnchallenge.FieldUserId:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case webauthnchallenge.FieldAllowedCredentialIds:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedCredentialIds(v)
		return nil
	case webauthnchallenge.FieldUserVerification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserVerification(v)
		return nil
	case webauthnchallenge.FieldExtensions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebAuthnChallengeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebAuthnChallengeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnChallengeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WebAuthnChallenge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebAuthnChallengeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webauthnchallenge.FieldSdChallenge) {
		fields = append(fields, webauthnchallenge.FieldSdChallenge)
	}
	if m.FieldCleared(webauthnchallenge.FieldUserId) {
		fields = append(fields, webauthnchallenge.FieldUserId)
	}
	if m.FieldCleared(webauthnchallenge.FieldAllowedCredentialIds) {
		fields = append(fields, webauthnchallenge.FieldAllowedCredentialIds)
	}
	if m.FieldCleared(webauthnchallenge.FieldUserVerification) {
		fields = append(fields, webauthnchallenge.FieldUserVerification)
	}
	if m.FieldCleared(webauthnchallenge.FieldExtensions) {
		fields = append(fields, webauthnchallenge.FieldExtensions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebAuthnChallengeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebAuthnChallengeMutation) ClearField(name string) error {
	switch name {
	case webauthnchallenge.FieldSdChallenge:
		m.ClearSdChallenge()
		return nil
	case webauthnchallenge.FieldUserId:
		m.ClearUserId()
		return nil
	case webauthnchallenge.FieldAllowedCredentialIds:
		m.ClearAllowedCredentialIds()
		return nil
	case webauthnchallenge.FieldUserVerification:
		m.ClearUserVerification()
		return nil
	case webauthnchallenge.FieldExtensions:
		m.ClearExtensions()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebAuthnChallengeMutation) ResetField(name string) error {
	switch name {
	case webauthnchallenge.FieldSdChallenge:
		m.ResetSdChallenge()
		return nil
	case webauthnchallenge.FieldUserId:
		m.ResetUserId()
		return nil
	case webauthnchallenge.FieldAllowedCredentialIds:
		m.ResetAllowedCredentialIds()
		return nil
	case webauthnchallenge.FieldUserVerification:
		m.ResetUserVerification()
		return nil
	case webauthnchallenge.FieldExtensions:
		m.ResetExtensions()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebAuthnChallengeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.challenge != nil {
		edges = append(edges, webauthnchallenge.EdgeChallenge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebAuthnChallengeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webauthnchallenge.EdgeChallenge:
		if id := m.challenge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebAuthnChallengeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebAuthnChallengeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebAuthnChallengeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchallenge {
		edges = append(edges, webauthnchallenge.EdgeChallenge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebAuthnChallengeMutation) EdgeCleared(name string) bool {
	switch name {
	case webauthnchallenge.EdgeChallenge:
		return m.clearedchallenge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebAuthnChallengeMutation) ClearEdge(name string) error {
	switch name {
	case webauthnchallenge.EdgeChallenge:
		m.ClearChallenge()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebAuthnChallengeMutation) ResetEdge(name string) error {
	switch name {
	case webauthnchallenge.EdgeChallenge:
		m.ResetChallenge()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge edge %s", name)
}

// WebAuthnCredentialMutation represents an operation that mutates the WebAuthnCredential nodes in the graph.
type WebAuthnCredentialMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	createdAt       *time.Time
	credentialId    *[]byte
	publicKey       *[]byte
	attestationType *string
	transport       *[]string
	appendtransport []string
	aaguid          *[]byte
	signCount       *uint32
	addsignCount    *int32
	cloneWarning    *bool
	clearedFields   map[string]struct{}
	user            *uuid.UUID
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*WebAuthnCredential, error)
	predicates      []predicate.WebAuthnCredential
}

var _ ent.Mutation = (*WebAuthnCredentialMutation)(nil)

// webauthncredentialOption allows management of the mutation configuration using functional options.
type webauthncredentialOption func(*WebAuthnCredentialMutation)

// newWebAuthnCredentialMutation creates new mutation for the WebAuthnCredential entity.
func newWebAuthnCredentialMutation(c config, op Op, opts ...webauthncredentialOption) *WebAuthnCredentialMutation {
	m := &WebAuthnCredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeWebAuthnCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebAuthnCredentialID sets the ID field of the mutation.
func withWebAuthnCredentialID(id uuid.UUID) webauthncredentialOption {
	return func(m *WebAuthnCredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *WebAuthnCredential
		)
		m.oldValue = func(ctx context.Context) (*WebAuthnCredential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebAuthnCredential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebAuthnCredential sets the old WebAuthnCredential of the mutation.
func withWebAuthnCredential(node *WebAuthnCredential) webauthncredentialOption {
	return func(m *WebAuthnCredentialMutation) {
		m.oldValue = func(context.Context) (*WebAuthnCredential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebAuthnCredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebAuthnCredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebAuthnCredential entities.
func (m *WebAuthnCredentialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebAuthnCredentialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebAuthnCredentialMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebAuthnCredential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WebAuthnCredentialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebAuthnCredentialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebAuthnCredentialMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *WebAuthnCredentialMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *WebAuthnCredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *WebAuthnCredentialMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetCredentialId sets the "credentialId" field.
func (m *WebAuthnCredentialMutation) SetCredentialId(b []byte) {
	m.credentialId = &b
}

// CredentialId returns the value of the "credentialId" field in the mutation.
func (m *WebAuthnCredentialMutation) CredentialId() (r []byte, exists bool) {
	v := m.credentialId
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialId returns the old "credentialId" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldCredentialId(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialId: %w", err)
	}
	return oldValue.CredentialId, nil
}

// ResetCredentialId resets all changes to the "credentialId" field.
func (m *WebAuthnCredentialMutation) ResetCredentialId() {
	m.credentialId = nil
}

// SetPublicKey sets the "publicKey" field.
func (m *WebAuthnCredentialMutation) SetPublicKey(b []byte) {
	m.publicKey = &b
}

// PublicKey returns the value of the "publicKey" field in the mutation.
func (m *WebAuthnCredentialMutation) PublicKey() (r []byte, exists bool) {
	v := m.publicKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "publicKey" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "publicKey" field.
func (m *WebAuthnCredentialMutation) ResetPublicKey() {
	m.publicKey = nil
}

// SetAttestationType sets the "attestationType" field.
func (m *WebAuthnCredentialMutation) SetAttestationType(s string) {
	m.attestationType = &s
}

// AttestationType returns the value of the "attestationType" field in the mutation.
func (m *WebAuthnCredentialMutation) AttestationType() (r string, exists bool) {
	v := m.attestationType
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestationType returns the old "attestationType" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldAttestationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestationType: %w", err)
	}
	return oldValue.AttestationType, nil
}

// ResetAttestationType resets all changes to the "attestationType" field.
func (m *WebAuthnCredentialMutation) ResetAttestationType() {
	m.attestationType = nil
}

// SetTransport sets the "transport" field.
func (m *WebAuthnCredentialMutation) SetTransport(s []string) {
	m.transport = &s
	m.appendtransport = nil
}

// Transport returns the value of the "transport" field in the mutation.
func (m *WebAuthnCredentialMutation) Transport() (r []string, exists bool) {
	v := m.transport
	if v == nil {
		return
	}
	return *v, true
}

// OldTransport returns the old "transport" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldTransport(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransport: %w", err)
	}
	return oldValue.Transport, nil
}

// AppendTransport adds s to the "transport" field.
func (m *WebAuthnCredentialMutation) AppendTransport(s []string) {
	m.appendtransport = append(m.appendtransport, s...)
}

// AppendedTransport returns the list of values that were appended to the "transport" field in this mutation.
func (m *WebAuthnCredentialMutation) AppendedTransport() ([]string, bool) {
	if len(m.appendtransport) == 0 {
		return nil, false
	}
	return m.appendtransport, true
}

// ResetTransport resets all changes to the "transport" field.
func (m *WebAuthnCredentialMutation) ResetTransport() {
	m.transport = nil
	m.appendtransport = nil
}

// SetAaguid sets the "aaguid" field.
func (m *WebAuthnCredentialMutation) SetAaguid(b []byte) {
	m.aaguid = &b
}

// Aaguid returns the value of the "aaguid" field in the mutation.
func (m *WebAuthnCredentialMutation) Aaguid() (r []byte, exists bool) {
	v := m.aaguid
	if v == nil {
		return
	}
	return *v, true
}

// OldAaguid returns the old "aaguid" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldAaguid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAaguid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAaguid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAaguid: %w", err)
	}
	return oldValue.Aaguid, nil
}

// ResetAaguid resets all changes to the "aaguid" field.
func (m *WebAuthnCredentialMutation) ResetAaguid() {
	m.aaguid = nil
}

// SetSignCount sets the "signCount" field.
func (m *WebAuthnCredentialMutation) SetSignCount(u uint32) {
	m.signCount = &u
	m.addsignCount = nil
}

// SignCount returns the value of the "signCount" field in the mutation.
func (m *WebAuthnCredentialMutation) SignCount() (r uint32, exists bool) {
	v := m.signCount
	if v == nil {
		return
	}
	return *v, true
}

// OldSignCount returns the old "signCount" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldSignCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignCount: %w", err)
	}
	return oldValue.SignCount, nil
}

// AddSignCount adds u to the "signCount" field.
func (m *WebAuthnCredentialMutation) AddSignCount(u int32) {
	if m.addsignCount != nil {
		*m.addsignCount += u
	} else {
		m.addsignCount = &u
	}
}

// AddedSignCount returns the value that was added to the "signCount" field in this mutation.
func (m *WebAuthnCredentialMutation) AddedSignCount() (r int32, exists bool) {
	v := m.addsignCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignCount resets all changes to the "signCount" field.
func (m *WebAuthnCredentialMutation) ResetSignCount() {
	m.signCount = nil
	m.addsignCount = nil
}

// SetCloneWarning sets the "cloneWarning" field.
func (m *WebAuthnCredentialMutation) SetCloneWarning(b bool) {
	m.cloneWarning = &b
}

// CloneWarning returns the value of the "cloneWarning" field in the mutation.
func (m *WebAuthnCredentialMutation) CloneWarning() (r bool, exists bool) {
	v := m.cloneWarning
	if v == nil {
		return
	}
	return *v, true
}

// OldCloneWarning returns the old "cloneWarning" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldCloneWarning(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloneWarning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloneWarning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloneWarning: %w", err)
	}
	return oldValue.CloneWarning, nil
}

// ResetCloneWarning resets all changes to the "cloneWarning" field.
func (m *WebAuthnCredentialMutation) ResetCloneWarning() {
	m.cloneWarning = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WebAuthnCredentialMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WebAuthnCredentialMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WebAuthnCredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WebAuthnCredentialMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WebAuthnCredentialMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WebAuthnCredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WebAuthnCredentialMutation builder.
func (m *WebAuthnCredentialMutation) Where(ps ...predicate.WebAuthnCredential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebAuthnCredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebAuthnCredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebAuthnCredential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebAuthnCredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebAuthnCredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebAuthnCredential).
func (m *WebAuthnCredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebAuthnCredentialMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, webauthncredential.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, webauthncredential.FieldCreatedAt)
	}
	if m.credentialId != nil {
		fields = append(fields, webauthncredential.FieldCredentialId)
	}
	if m.publicKey != nil {
		fields = append(fields, webauthncredential.FieldPublicKey)
	}
	if m.attestationType != nil {
		fields = append(fields, webauthncredential.FieldAttestationType)
	}
	if m.transport != nil {
		fields = append(fields, webauthncredential.FieldTransport)
	}
	if m.aaguid != nil {
		fields = append(fields, webauthncredential.FieldAaguid)
	}
	if m.signCount != nil {
		fields = append(fields, webauthncredential.FieldSignCount)
	}
	if m.cloneWarning != nil {
		fields = append(fields, webauthncredential.FieldCloneWarning)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebAuthnCredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webauthncredential.FieldName:
		return m.Name()
	case webauthncredential.FieldCreatedAt:
		return m.CreatedAt()
	case webauthncredential.FieldCredentialId:
		return m.CredentialId()
	case webauthncredential.FieldPublicKey:
		return m.PublicKey()
	case webauthncredential.FieldAttestationType:
		return m.AttestationType()
	case webauthncredential.FieldTransport:
		return m.Transport()
	case webauthncredential.FieldAaguid:
		return m.Aaguid()
	case webauthncredential.FieldSignCount:
		return m.SignCount()
	case webauthncredential.FieldCloneWarning:
		return m.CloneWarning()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebAuthnCredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webauthncredential.FieldName:
		return m.OldName(ctx)
	case webauthncredential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webauthncredential.FieldCredentialId:
		return m.OldCredentialId(ctx)
	case webauthncredential.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case webauthncredential.FieldAttestationType:
		return m.OldAttestationType(ctx)
	case webauthncredential.FieldTransport:
		return m.OldTransport(ctx)
	case webauthncredential.FieldAaguid:
		return m.OldAaguid(ctx)
	case webauthncredential.FieldSignCount:
		return m.OldSignCount(ctx)
	case webauthncredential.FieldCloneWarning:
		return m.OldCloneWarning(ctx)
	}
	return nil, fmt.Errorf("unknown WebAuthnCredential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnCredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webauthncredential.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webauthncredential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webauthncredential.FieldCredentialId:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialId(v)
		return nil
	case webauthncredential.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case webauthncredential.FieldAttestationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestationType(v)
		return nil
	case webauthncredential.FieldTransport:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransport(v)
		return nil
	case webauthncredential.FieldAaguid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAaguid(v)
		return nil
	case webauthncredential.FieldSignCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignCount(v)
		return nil
	case webauthncredential.FieldCloneWarning:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloneWarning(v)
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebAuthnCredentialMutation) AddedFields() []string {
	var fields []string
	if m.addsignCount != nil {
		fields = append(fields, webauthncredential.FieldSignCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebAuthnCredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webauthncredential.FieldSignCount:
		return m.AddedSignCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnCredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webauthncredential.FieldSignCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignCount(v)
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebAuthnCredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebAuthnCredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebAuthnCredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WebAuthnCredential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebAuthnCredentialMutation) ResetField(name string) error {
	switch name {
	case webauthncredential.FieldName:
		m.ResetName()
		return nil
	case webauthncredential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webauthncredential.FieldCredentialId:
		m.ResetCredentialId()
		return nil
	case webauthncredential.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case webauthncredential.FieldAttestationType:
		m.ResetAttestationType()
		return nil
	case webauthncredential.FieldTransport:
		m.ResetTransport()
		return nil
	case webauthncredential.FieldAaguid:
		m.ResetAaguid()
		return nil
	case webauthncredential.FieldSignCount:
		m.ResetSignCount()
		return nil
	case webauthncredential.FieldCloneWarning:
		m.ResetCloneWarning()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebAuthnCredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, webauthncredential.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebAuthnCredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webauthncredential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebAuthnCredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebAuthnCredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebAuthnCredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, webauthncredential.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebAuthnCredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case webauthncredential.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebAuthnCredentialMutation) ClearEdge(name string) error {
	switch name {
	case webauthncredential.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebAuthnCredentialMutation) ResetEdge(name string) error {
	switch name {
	case webauthncredential.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential edge %s", name)
}

// WebAuthnRegisterChallengeMutation represents an operation that mutates the WebAuthnRegisterChallenge nodes in the graph.
type WebAuthnRegisterChallengeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	sdChallenge                *string
	userId                     *[]byte
	allowedCredentialIds       *[][]uint8
	appendallowedCredentialIds [][]uint8
	userVerification           *string
	extensions                 *map[string]interface{}
	clearedFields              map[string]struct{}
	user                       *uuid.UUID
	cleareduser                bool
	done                       bool
	oldValue                   func(context.Context) (*WebAuthnRegisterChallenge, error)
	predicates                 []predicate.WebAuthnRegisterChallenge
}

var _ ent.Mutation = (*WebAuthnRegisterChallengeMutation)(nil)

// webauthnregisterchallengeOption allows management of the mutation configuration using functional options.
type webauthnregisterchallengeOption func(*WebAuthnRegisterChallengeMutation)

// newWebAuthnRegisterChallengeMutation creates new mutation for the WebAuthnRegisterChallenge entity.
func newWebAuthnRegisterChallengeMutation(c config, op Op, opts ...webauthnregisterchallengeOption) *WebAuthnRegisterChallengeMutation {
	m := &WebAuthnRegisterChallengeMutation{
		config:        c,
		op:            op,
		typ:           TypeWebAuthnRegisterChallenge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebAuthnRegisterChallengeID sets the ID field of the mutation.
func withWebAuthnRegisterChallengeID(id uuid.UUID) webauthnregisterchallengeOption {
	return func(m *WebAuthnRegisterChallengeMutation) {
		var (
			err   error
			once  sync.Once
			value *WebAuthnRegisterChallenge
		)
		m.oldValue = func(ctx context.Context) (*WebAuthnRegisterChallenge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebAuthnRegisterChallenge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebAuthnRegisterChallenge sets the old WebAuthnRegisterChallenge of the mutation.
func withWebAuthnRegisterChallenge(node *WebAuthnRegisterChallenge) webauthnregisterchallengeOption {
	return func(m *WebAuthnRegisterChallengeMutation) {
		m.oldValue = func(context.Context) (*WebAuthnRegisterChallenge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebAuthnRegisterChallengeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebAuthnRegisterChallengeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebAuthnRegisterChallenge entities.
func (m *WebAuthnRegisterChallengeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebAuthnRegisterChallengeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebAuthnRegisterChallengeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebAuthnRegisterChallenge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSdChallenge sets the "sdChallenge" field.
func (m *WebAuthnRegisterChallengeMutation) SetSdChallenge(s string) {
	m.sdChallenge = &s
}

// SdChallenge returns the value of the "sdChallenge" field in the mutation.
func (m *WebAuthnRegisterChallengeMutation) SdChallenge() (r string, exists bool) {
	v := m.sdChallenge
	if v == nil {
		return
	}
	return *v, true
}

// OldSdChallenge returns the old "sdChallenge" field's value of the WebAuthnRegisterChallenge entity.
// If the WebAuthnRegisterChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnRegisterChallengeMutation) OldSdChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSdChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSdChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSdChallenge: %w", err)
	}
	return oldValue.SdChallenge, nil
}

// ClearSdChallenge clears the value of the "sdChallenge" field.
func (m *WebAuthnRegisterChallengeMutation) ClearSdChallenge() {
	m.sdChallenge = nil
	m.clearedFields[webauthnregisterchallenge.FieldSdChallenge] = struct{}{}
}

// SdChallengeCleared returns if the "sdChallenge" field was cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) SdChallengeCleared() bool {
	_, ok := m.clearedFields[webauthnregisterchallenge.FieldSdChallenge]
	return ok
}

// ResetSdChallenge resets all changes to the "sdChallenge" field.
func (m *WebAuthnRegisterChallengeMutation) ResetSdChallenge() {
	m.sdChallenge = nil
	delete(m.clearedFields, webauthnregisterchallenge.FieldSdChallenge)
}

// SetUserId sets the "userId" field.
func (m *WebAuthnRegisterChallengeMutation) SetUserId(b []byte) {
	m.userId = &b
}

// UserId returns the value of the "userId" field in the mutation.
func (m *WebAuthnRegisterChallengeMutation) UserId() (r []byte, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the WebAuthnRegisterChallenge entity.
// If the WebAuthnRegisterChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnRegisterChallengeMutation) OldUserId(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "userId" field.
func (m *WebAuthnRegisterChallengeMutation) ClearUserId() {
	m.userId = nil
	m.clearedFields[webauthnregisterchallenge.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[webauthnregisterchallenge.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *WebAuthnRegisterChallengeMutation) ResetUserId() {
	m.userId = nil
	delete(m.clearedFields, webauthnregisterchallenge.FieldUserId)
}

// SetAllowedCredentialIds sets the "allowedCredentialIds" field.
func (m *WebAuthnRegisterChallengeMutation) SetAllowedCredentialIds(u [][]uint8) {
	m.allowedCredentialIds = &u
	m.appendallowedCredentialIds = nil
}

// AllowedCredentialIds returns the value of the "allowedCredentialIds" field in the mutation.
func (m *WebAuthnRegisterChallengeMutation) AllowedCredentialIds() (r [][]uint8, exists bool) {
	v := m.allowedCredentialIds
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedCredentialIds returns the old "allowedCredentialIds" field's value of the WebAuthnRegisterChallenge entity.
// If the WebAuthnRegisterChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnRegisterChallengeMutation) OldAllowedCredentialIds(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedCredentialIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedCredentialIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedCredentialIds: %w", err)
	}
	return oldValue.AllowedCredentialIds, nil
}

// AppendAllowedCredentialIds adds u to the "allowedCredentialIds" field.
func (m *WebAuthnRegisterChallengeMutation) AppendAllowedCredentialIds(u [][]uint8) {
	m.appendallowedCredentialIds = append(m.appendallowedCredentialIds, u...)
}

// AppendedAllowedCredentialIds returns the list of values that were appended to the "allowedCredentialIds" field in this mutation.
func (m *WebAuthnRegisterChallengeMutation) AppendedAllowedCredentialIds() ([][]uint8, bool) {
	if len(m.appendallowedCredentialIds) == 0 {
		return nil, false
	}
	return m.appendallowedCredentialIds, true
}

// ClearAllowedCredentialIds clears the value of the "allowedCredentialIds" field.
func (m *WebAuthnRegisterChallengeMutation) ClearAllowedCredentialIds() {
	m.allowedCredentialIds = nil
	m.appendallowedCredentialIds = nil
	m.clearedFields[webauthnregisterchallenge.FieldAllowedCredentialIds] = struct{}{}
}

// AllowedCredentialIdsCleared returns if the "allowedCredentialIds" field was cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) AllowedCredentialIdsCleared() bool {
	_, ok := m.clearedFields[webauthnregisterchallenge.FieldAllowedCredentialIds]
	return ok
}

// ResetAllowedCredentialIds resets all changes to the "allowedCredentialIds" field.
func (m *WebAuthnRegisterChallengeMutation) ResetAllowedCredentialIds() {
	m.allowedCredentialIds = nil
	m.appendallowedCredentialIds = nil
	delete(m.clearedFields, webauthnregisterchallenge.FieldAllowedCredentialIds)
}

// SetUserVerification sets the "userVerification" field.
func (m *WebAuthnRegisterChallengeMutation) SetUserVerification(s string) {
	m.userVerification = &s
}

// UserVerification returns the value of the "userVerification" field in the mutation.
func (m *WebAuthnRegisterChallengeMutation) UserVerification() (r string, exists bool) {
	v := m.userVerification
	if v == nil {
		return
	}
	return *v, true
}

// OldUserVerification returns the old "userVerification" field's value of the WebAuthnRegisterChallenge entity.
// If the WebAuthnRegisterChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnRegisterChallengeMutation) OldUserVerification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserVerification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserVerification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserVerification: %w", err)
	}
	return oldValue.UserVerification, nil
}

// ClearUserVerification clears the value of the "userVerification" field.
func (m *WebAuthnRegisterChallengeMutation) ClearUserVerification() {
	m.userVerification = nil
	m.clearedFields[webauthnregisterchallenge.FieldUserVerification] = struct{}{}
}

// UserVerificationCleared returns if the "userVerification" field was cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) UserVerificationCleared() bool {
	_, ok := m.clearedFields[webauthnregisterchallenge.FieldUserVerification]
	return ok
}

// ResetUserVerification resets all changes to the "userVerification" field.
func (m *WebAuthnRegisterChallengeMutation) ResetUserVerification() {
	m.userVerification = nil
	delete(m.clearedFields, webauthnregisterchallenge.FieldUserVerification)
}

// SetExtensions sets the "extensions" field.
func (m *WebAuthnRegisterChallengeMutation) SetExtensions(value map[string]interface{}) {
	m.extensions = &value
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *WebAuthnRegisterChallengeMutation) Extensions() (r map[string]interface{}, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the WebAuthnRegisterChallenge entity.
// If the WebAuthnRegisterChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnRegisterChallengeMutation) OldExtensions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ClearExtensions clears the value of the "extensions" field.
func (m *WebAuthnRegisterChallengeMutation) ClearExtensions() {
	m.extensions = nil
	m.clearedFields[webauthnregisterchallenge.FieldExtensions] = struct{}{}
}

// ExtensionsCleared returns if the "extensions" field was cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) ExtensionsCleared() bool {
	_, ok := m.clearedFields[webauthnregisterchallenge.FieldExtensions]
	return ok
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *WebAuthnRegisterChallengeMutation) ResetExtensions() {
	m.extensions = nil
	delete(m.clearedFields, webauthnregisterchallenge.FieldExtensions)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WebAuthnRegisterChallengeMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WebAuthnRegisterChallengeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WebAuthnRegisterChallengeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WebAuthnRegisterChallengeMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WebAuthnRegisterChallengeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WebAuthnRegisterChallengeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WebAuthnRegisterChallengeMutation builder.
func (m *WebAuthnRegisterChallengeMutation) Where(ps ...predicate.WebAuthnRegisterChallenge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebAuthnRegisterChallengeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebAuthnRegisterChallengeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebAuthnRegisterChallenge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebAuthnRegisterChallengeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebAuthnRegisterChallengeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebAuthnRegisterChallenge).
func (m *WebAuthnRegisterChallengeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebAuthnRegisterChallengeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sdChallenge != nil {
		fields = append(fields, webauthnregisterchallenge.FieldSdChallenge)
	}
	if m.userId != nil {
		fields = append(fields, webauthnregisterchallenge.FieldUserId)
	}
	if m.allowedCredentialIds != nil {
		fields = append(fields, webauthnregisterchallenge.FieldAllowedCredentialIds)
	}
	if m.userVerification != nil {
		fields = append(fields, webauthnregisterchallenge.FieldUserVerification)
	}
	if m.extensions != nil {
		fields = append(fields, webauthnregisterchallenge.FieldExtensions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebAuthnRegisterChallengeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webauthnregisterchallenge.FieldSdChallenge:
		return m.SdChallenge()
	case webauthnregisterchallenge.FieldUserId:
		return m.UserId()
	case webauthnregisterchallenge.FieldAllowedCredentialIds:
		return m.AllowedCredentialIds()
	case webauthnregisterchallenge.FieldUserVerification:
		return m.UserVerification()
	case webauthnregisterchallenge.FieldExtensions:
		return m.Extensions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebAuthnRegisterChallengeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webauthnregisterchallenge.FieldSdChallenge:
		return m.OldSdChallenge(ctx)
	case webauthnregisterchallenge.FieldUserId:
		return m.OldUserId(ctx)
	case webauthnregisterchallenge.FieldAllowedCredentialIds:
		return m.OldAllowedCredentialIds(ctx)
	case webauthnregisterchallenge.FieldUserVerification:
		return m.OldUserVerification(ctx)
	case webauthnregisterchallenge.FieldExtensions:
		return m.OldExtensions(ctx)
	}
	return nil, fmt.Errorf("unknown WebAuthnRegisterChallenge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnRegisterChallengeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webauthnregisterchallenge.FieldSdChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSdChallenge(v)
		return nil
	case webauthnregisterchallenge.FieldUserId:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case webauthnregisterchallenge.FieldAllowedCredentialIds:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedCredentialIds(v)
		return nil
	case webauthnregisterchallenge.FieldUserVerification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserVerification(v)
		return nil
	case webauthnregisterchallenge.FieldExtensions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	}
	return fmt.Errorf("unknown WebAuthnRegisterChallenge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebAuthnRegisterChallengeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebAuthnRegisterChallengeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnRegisterChallengeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WebAuthnRegisterChallenge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebAuthnRegisterChallengeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webauthnregisterchallenge.FieldSdChallenge) {
		fields = append(fields, webauthnregisterchallenge.FieldSdChallenge)
	}
	if m.FieldCleared(webauthnregisterchallenge.FieldUserId) {
		fields = append(fields, webauthnregisterchallenge.FieldUserId)
	}
	if m.FieldCleared(webauthnregisterchallenge.FieldAllowedCredentialIds) {
		fields = append(fields, webauthnregisterchallenge.FieldAllowedCredentialIds)
	}
	if m.FieldCleared(webauthnregisterchallenge.FieldUserVerification) {
		fields = append(fields, webauthnregisterchallenge.FieldUserVerification)
	}
	if m.FieldCleared(webauthnregisterchallenge.FieldExtensions) {
		fields = append(fields, webauthnregisterchallenge.FieldExtensions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebAuthnRegisterChallengeMutation) ClearField(name string) error {
	switch name {
	case webauthnregisterchallenge.FieldSdChallenge:
		m.ClearSdChallenge()
		return nil
	case webauthnregisterchallenge.FieldUserId:
		m.ClearUserId()
		return nil
	case webauthnregisterchallenge.FieldAllowedCredentialIds:
		m.ClearAllowedCredentialIds()
		return nil
	case webauthnregisterchallenge.FieldUserVerification:
		m.ClearUserVerification()
		return nil
	case webauthnregisterchallenge.FieldExtensions:
		m.ClearExtensions()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnRegisterChallenge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebAuthnRegisterChallengeMutation) ResetField(name string) error {
	switch name {
	case webauthnregisterchallenge.FieldSdChallenge:
		m.ResetSdChallenge()
		return nil
	case webauthnregisterchallenge.FieldUserId:
		m.ResetUserId()
		return nil
	case webauthnregisterchallenge.FieldAllowedCredentialIds:
		m.ResetAllowedCredentialIds()
		return nil
	case webauthnregisterchallenge.FieldUserVerification:
		m.ResetUserVerification()
		return nil
	case webauthnregisterchallenge.FieldExtensions:
		m.ResetExtensions()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnRegisterChallenge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebAuthnRegisterChallengeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, webauthnregisterchallenge.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebAuthnRegisterChallengeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webauthnregisterchallenge.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebAuthnRegisterChallengeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebAuthnRegisterChallengeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, webauthnregisterchallenge.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebAuthnRegisterChallengeMutation) EdgeCleared(name string) bool {
	switch name {
	case webauthnregisterchallenge.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebAuthnRegisterChallengeMutation) ClearEdge(name string) error {
	switch name {
	case webauthnregisterchallenge.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnRegisterChallenge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebAuthnRegisterChallengeMutation) ResetEdge(name string) error {
	switch name {
	case webauthnregisterchallenge.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnRegisterChallenge edge %s", name)
}
