// Code generated by ent, DO NOT EDIT.

package ent

import (
	"PasswordManager/ent/additionalfield"
	"PasswordManager/ent/emailchallenge"
	"PasswordManager/ent/password"
	"PasswordManager/ent/predicate"
	"PasswordManager/ent/session"
	"PasswordManager/ent/url"
	"PasswordManager/ent/user"
	"PasswordManager/ent/webauthnchallenge"
	"PasswordManager/ent/webauthncredential"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdditionalField    = "AdditionalField"
	TypeEmailChallenge     = "EmailChallenge"
	TypePassword           = "Password"
	TypeSession            = "Session"
	TypeURL                = "Url"
	TypeUser               = "User"
	TypeWebAuthnChallenge  = "WebAuthnChallenge"
	TypeWebAuthnCredential = "WebAuthnCredential"
)

// AdditionalFieldMutation represents an operation that mutates the AdditionalField nodes in the graph.
type AdditionalFieldMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	key             *[]byte
	keyIv           *[]byte
	value           *[]byte
	valueIv         *[]byte
	clearedFields   map[string]struct{}
	password        *uuid.UUID
	clearedpassword bool
	done            bool
	oldValue        func(context.Context) (*AdditionalField, error)
	predicates      []predicate.AdditionalField
}

var _ ent.Mutation = (*AdditionalFieldMutation)(nil)

// additionalfieldOption allows management of the mutation configuration using functional options.
type additionalfieldOption func(*AdditionalFieldMutation)

// newAdditionalFieldMutation creates new mutation for the AdditionalField entity.
func newAdditionalFieldMutation(c config, op Op, opts ...additionalfieldOption) *AdditionalFieldMutation {
	m := &AdditionalFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeAdditionalField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdditionalFieldID sets the ID field of the mutation.
func withAdditionalFieldID(id uuid.UUID) additionalfieldOption {
	return func(m *AdditionalFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *AdditionalField
		)
		m.oldValue = func(ctx context.Context) (*AdditionalField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdditionalField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdditionalField sets the old AdditionalField of the mutation.
func withAdditionalField(node *AdditionalField) additionalfieldOption {
	return func(m *AdditionalFieldMutation) {
		m.oldValue = func(context.Context) (*AdditionalField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdditionalFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdditionalFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdditionalField entities.
func (m *AdditionalFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdditionalFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdditionalFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdditionalField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *AdditionalFieldMutation) SetKey(b []byte) {
	m.key = &b
}

// Key returns the value of the "key" field in the mutation.
func (m *AdditionalFieldMutation) Key() (r []byte, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *AdditionalFieldMutation) ResetKey() {
	m.key = nil
}

// SetKeyIv sets the "keyIv" field.
func (m *AdditionalFieldMutation) SetKeyIv(b []byte) {
	m.keyIv = &b
}

// KeyIv returns the value of the "keyIv" field in the mutation.
func (m *AdditionalFieldMutation) KeyIv() (r []byte, exists bool) {
	v := m.keyIv
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyIv returns the old "keyIv" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldKeyIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyIv: %w", err)
	}
	return oldValue.KeyIv, nil
}

// ResetKeyIv resets all changes to the "keyIv" field.
func (m *AdditionalFieldMutation) ResetKeyIv() {
	m.keyIv = nil
}

// SetValue sets the "value" field.
func (m *AdditionalFieldMutation) SetValue(b []byte) {
	m.value = &b
}

// Value returns the value of the "value" field in the mutation.
func (m *AdditionalFieldMutation) Value() (r []byte, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldValue(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AdditionalFieldMutation) ResetValue() {
	m.value = nil
}

// SetValueIv sets the "valueIv" field.
func (m *AdditionalFieldMutation) SetValueIv(b []byte) {
	m.valueIv = &b
}

// ValueIv returns the value of the "valueIv" field in the mutation.
func (m *AdditionalFieldMutation) ValueIv() (r []byte, exists bool) {
	v := m.valueIv
	if v == nil {
		return
	}
	return *v, true
}

// OldValueIv returns the old "valueIv" field's value of the AdditionalField entity.
// If the AdditionalField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFieldMutation) OldValueIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueIv: %w", err)
	}
	return oldValue.ValueIv, nil
}

// ResetValueIv resets all changes to the "valueIv" field.
func (m *AdditionalFieldMutation) ResetValueIv() {
	m.valueIv = nil
}

// SetPasswordID sets the "password" edge to the Password entity by id.
func (m *AdditionalFieldMutation) SetPasswordID(id uuid.UUID) {
	m.password = &id
}

// ClearPassword clears the "password" edge to the Password entity.
func (m *AdditionalFieldMutation) ClearPassword() {
	m.clearedpassword = true
}

// PasswordCleared reports if the "password" edge to the Password entity was cleared.
func (m *AdditionalFieldMutation) PasswordCleared() bool {
	return m.clearedpassword
}

// PasswordID returns the "password" edge ID in the mutation.
func (m *AdditionalFieldMutation) PasswordID() (id uuid.UUID, exists bool) {
	if m.password != nil {
		return *m.password, true
	}
	return
}

// PasswordIDs returns the "password" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PasswordID instead. It exists only for internal usage by the builders.
func (m *AdditionalFieldMutation) PasswordIDs() (ids []uuid.UUID) {
	if id := m.password; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPassword resets all changes to the "password" edge.
func (m *AdditionalFieldMutation) ResetPassword() {
	m.password = nil
	m.clearedpassword = false
}

// Where appends a list predicates to the AdditionalFieldMutation builder.
func (m *AdditionalFieldMutation) Where(ps ...predicate.AdditionalField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdditionalFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdditionalFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdditionalField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdditionalFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdditionalFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdditionalField).
func (m *AdditionalFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdditionalFieldMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.key != nil {
		fields = append(fields, additionalfield.FieldKey)
	}
	if m.keyIv != nil {
		fields = append(fields, additionalfield.FieldKeyIv)
	}
	if m.value != nil {
		fields = append(fields, additionalfield.FieldValue)
	}
	if m.valueIv != nil {
		fields = append(fields, additionalfield.FieldValueIv)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdditionalFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case additionalfield.FieldKey:
		return m.Key()
	case additionalfield.FieldKeyIv:
		return m.KeyIv()
	case additionalfield.FieldValue:
		return m.Value()
	case additionalfield.FieldValueIv:
		return m.ValueIv()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdditionalFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case additionalfield.FieldKey:
		return m.OldKey(ctx)
	case additionalfield.FieldKeyIv:
		return m.OldKeyIv(ctx)
	case additionalfield.FieldValue:
		return m.OldValue(ctx)
	case additionalfield.FieldValueIv:
		return m.OldValueIv(ctx)
	}
	return nil, fmt.Errorf("unknown AdditionalField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdditionalFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case additionalfield.FieldKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case additionalfield.FieldKeyIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyIv(v)
		return nil
	case additionalfield.FieldValue:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case additionalfield.FieldValueIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueIv(v)
		return nil
	}
	return fmt.Errorf("unknown AdditionalField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdditionalFieldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdditionalFieldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdditionalFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdditionalField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdditionalFieldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdditionalFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdditionalFieldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdditionalField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdditionalFieldMutation) ResetField(name string) error {
	switch name {
	case additionalfield.FieldKey:
		m.ResetKey()
		return nil
	case additionalfield.FieldKeyIv:
		m.ResetKeyIv()
		return nil
	case additionalfield.FieldValue:
		m.ResetValue()
		return nil
	case additionalfield.FieldValueIv:
		m.ResetValueIv()
		return nil
	}
	return fmt.Errorf("unknown AdditionalField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdditionalFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.password != nil {
		edges = append(edges, additionalfield.EdgePassword)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdditionalFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case additionalfield.EdgePassword:
		if id := m.password; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdditionalFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdditionalFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdditionalFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpassword {
		edges = append(edges, additionalfield.EdgePassword)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdditionalFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case additionalfield.EdgePassword:
		return m.clearedpassword
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdditionalFieldMutation) ClearEdge(name string) error {
	switch name {
	case additionalfield.EdgePassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown AdditionalField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdditionalFieldMutation) ResetEdge(name string) error {
	switch name {
	case additionalfield.EdgePassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown AdditionalField edge %s", name)
}

// EmailChallengeMutation represents an operation that mutates the EmailChallenge nodes in the graph.
type EmailChallengeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	code          *string
	expiry        *time.Time
	_for          *emailchallenge.For
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*EmailChallenge, error)
	predicates    []predicate.EmailChallenge
}

var _ ent.Mutation = (*EmailChallengeMutation)(nil)

// emailchallengeOption allows management of the mutation configuration using functional options.
type emailchallengeOption func(*EmailChallengeMutation)

// newEmailChallengeMutation creates new mutation for the EmailChallenge entity.
func newEmailChallengeMutation(c config, op Op, opts ...emailchallengeOption) *EmailChallengeMutation {
	m := &EmailChallengeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailChallenge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailChallengeID sets the ID field of the mutation.
func withEmailChallengeID(id uuid.UUID) emailchallengeOption {
	return func(m *EmailChallengeMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailChallenge
		)
		m.oldValue = func(ctx context.Context) (*EmailChallenge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailChallenge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailChallenge sets the old EmailChallenge of the mutation.
func withEmailChallenge(node *EmailChallenge) emailchallengeOption {
	return func(m *EmailChallengeMutation) {
		m.oldValue = func(context.Context) (*EmailChallenge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailChallengeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailChallengeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailChallenge entities.
func (m *EmailChallengeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailChallengeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailChallengeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailChallenge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *EmailChallengeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EmailChallengeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the EmailChallenge entity.
// If the EmailChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailChallengeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *EmailChallengeMutation) ResetCode() {
	m.code = nil
}

// SetExpiry sets the "expiry" field.
func (m *EmailChallengeMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *EmailChallengeMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the EmailChallenge entity.
// If the EmailChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailChallengeMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *EmailChallengeMutation) ResetExpiry() {
	m.expiry = nil
}

// SetFor sets the "for" field.
func (m *EmailChallengeMutation) SetFor(e emailchallenge.For) {
	m._for = &e
}

// For returns the value of the "for" field in the mutation.
func (m *EmailChallengeMutation) For() (r emailchallenge.For, exists bool) {
	v := m._for
	if v == nil {
		return
	}
	return *v, true
}

// OldFor returns the old "for" field's value of the EmailChallenge entity.
// If the EmailChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailChallengeMutation) OldFor(ctx context.Context) (v emailchallenge.For, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFor: %w", err)
	}
	return oldValue.For, nil
}

// ResetFor resets all changes to the "for" field.
func (m *EmailChallengeMutation) ResetFor() {
	m._for = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EmailChallengeMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EmailChallengeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EmailChallengeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EmailChallengeMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EmailChallengeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EmailChallengeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EmailChallengeMutation builder.
func (m *EmailChallengeMutation) Where(ps ...predicate.EmailChallenge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailChallengeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailChallengeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailChallenge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailChallengeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailChallengeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailChallenge).
func (m *EmailChallengeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailChallengeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.code != nil {
		fields = append(fields, emailchallenge.FieldCode)
	}
	if m.expiry != nil {
		fields = append(fields, emailchallenge.FieldExpiry)
	}
	if m._for != nil {
		fields = append(fields, emailchallenge.FieldFor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailChallengeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailchallenge.FieldCode:
		return m.Code()
	case emailchallenge.FieldExpiry:
		return m.Expiry()
	case emailchallenge.FieldFor:
		return m.For()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailChallengeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailchallenge.FieldCode:
		return m.OldCode(ctx)
	case emailchallenge.FieldExpiry:
		return m.OldExpiry(ctx)
	case emailchallenge.FieldFor:
		return m.OldFor(ctx)
	}
	return nil, fmt.Errorf("unknown EmailChallenge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailChallengeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailchallenge.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case emailchallenge.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case emailchallenge.FieldFor:
		v, ok := value.(emailchallenge.For)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFor(v)
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailChallengeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailChallengeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailChallengeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailChallenge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailChallengeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailChallengeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailChallengeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmailChallenge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailChallengeMutation) ResetField(name string) error {
	switch name {
	case emailchallenge.FieldCode:
		m.ResetCode()
		return nil
	case emailchallenge.FieldExpiry:
		m.ResetExpiry()
		return nil
	case emailchallenge.FieldFor:
		m.ResetFor()
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailChallengeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, emailchallenge.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailChallengeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailchallenge.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailChallengeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailChallengeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailChallengeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, emailchallenge.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailChallengeMutation) EdgeCleared(name string) bool {
	switch name {
	case emailchallenge.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailChallengeMutation) ClearEdge(name string) error {
	switch name {
	case emailchallenge.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailChallengeMutation) ResetEdge(name string) error {
	switch name {
	case emailchallenge.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown EmailChallenge edge %s", name)
}

// PasswordMutation represents an operation that mutates the Password nodes in the graph.
type PasswordMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	name                    *[]byte
	nameIv                  *[]byte
	username                *[]byte
	usernameIv              *[]byte
	password                *[]byte
	passwordIv              *[]byte
	colour                  *string
	clearedFields           map[string]struct{}
	additionalFields        map[uuid.UUID]struct{}
	removedadditionalFields map[uuid.UUID]struct{}
	clearedadditionalFields bool
	urls                    map[uuid.UUID]struct{}
	removedurls             map[uuid.UUID]struct{}
	clearedurls             bool
	done                    bool
	oldValue                func(context.Context) (*Password, error)
	predicates              []predicate.Password
}

var _ ent.Mutation = (*PasswordMutation)(nil)

// passwordOption allows management of the mutation configuration using functional options.
type passwordOption func(*PasswordMutation)

// newPasswordMutation creates new mutation for the Password entity.
func newPasswordMutation(c config, op Op, opts ...passwordOption) *PasswordMutation {
	m := &PasswordMutation{
		config:        c,
		op:            op,
		typ:           TypePassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordID sets the ID field of the mutation.
func withPasswordID(id uuid.UUID) passwordOption {
	return func(m *PasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *Password
		)
		m.oldValue = func(ctx context.Context) (*Password, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Password.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPassword sets the old Password of the mutation.
func withPassword(node *Password) passwordOption {
	return func(m *PasswordMutation) {
		m.oldValue = func(context.Context) (*Password, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Password entities.
func (m *PasswordMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Password.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PasswordMutation) SetName(b []byte) {
	m.name = &b
}

// Name returns the value of the "name" field in the mutation.
func (m *PasswordMutation) Name() (r []byte, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldName(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PasswordMutation) ResetName() {
	m.name = nil
}

// SetNameIv sets the "nameIv" field.
func (m *PasswordMutation) SetNameIv(b []byte) {
	m.nameIv = &b
}

// NameIv returns the value of the "nameIv" field in the mutation.
func (m *PasswordMutation) NameIv() (r []byte, exists bool) {
	v := m.nameIv
	if v == nil {
		return
	}
	return *v, true
}

// OldNameIv returns the old "nameIv" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldNameIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameIv: %w", err)
	}
	return oldValue.NameIv, nil
}

// ResetNameIv resets all changes to the "nameIv" field.
func (m *PasswordMutation) ResetNameIv() {
	m.nameIv = nil
}

// SetUsername sets the "username" field.
func (m *PasswordMutation) SetUsername(b []byte) {
	m.username = &b
}

// Username returns the value of the "username" field in the mutation.
func (m *PasswordMutation) Username() (r []byte, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUsername(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *PasswordMutation) ResetUsername() {
	m.username = nil
}

// SetUsernameIv sets the "usernameIv" field.
func (m *PasswordMutation) SetUsernameIv(b []byte) {
	m.usernameIv = &b
}

// UsernameIv returns the value of the "usernameIv" field in the mutation.
func (m *PasswordMutation) UsernameIv() (r []byte, exists bool) {
	v := m.usernameIv
	if v == nil {
		return
	}
	return *v, true
}

// OldUsernameIv returns the old "usernameIv" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUsernameIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsernameIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsernameIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsernameIv: %w", err)
	}
	return oldValue.UsernameIv, nil
}

// ResetUsernameIv resets all changes to the "usernameIv" field.
func (m *PasswordMutation) ResetUsernameIv() {
	m.usernameIv = nil
}

// SetPassword sets the "password" field.
func (m *PasswordMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *PasswordMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *PasswordMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordIv sets the "passwordIv" field.
func (m *PasswordMutation) SetPasswordIv(b []byte) {
	m.passwordIv = &b
}

// PasswordIv returns the value of the "passwordIv" field in the mutation.
func (m *PasswordMutation) PasswordIv() (r []byte, exists bool) {
	v := m.passwordIv
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordIv returns the old "passwordIv" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldPasswordIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordIv: %w", err)
	}
	return oldValue.PasswordIv, nil
}

// ResetPasswordIv resets all changes to the "passwordIv" field.
func (m *PasswordMutation) ResetPasswordIv() {
	m.passwordIv = nil
}

// SetColour sets the "colour" field.
func (m *PasswordMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *PasswordMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ClearColour clears the value of the "colour" field.
func (m *PasswordMutation) ClearColour() {
	m.colour = nil
	m.clearedFields[password.FieldColour] = struct{}{}
}

// ColourCleared returns if the "colour" field was cleared in this mutation.
func (m *PasswordMutation) ColourCleared() bool {
	_, ok := m.clearedFields[password.FieldColour]
	return ok
}

// ResetColour resets all changes to the "colour" field.
func (m *PasswordMutation) ResetColour() {
	m.colour = nil
	delete(m.clearedFields, password.FieldColour)
}

// AddAdditionalFieldIDs adds the "additionalFields" edge to the AdditionalField entity by ids.
func (m *PasswordMutation) AddAdditionalFieldIDs(ids ...uuid.UUID) {
	if m.additionalFields == nil {
		m.additionalFields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.additionalFields[ids[i]] = struct{}{}
	}
}

// ClearAdditionalFields clears the "additionalFields" edge to the AdditionalField entity.
func (m *PasswordMutation) ClearAdditionalFields() {
	m.clearedadditionalFields = true
}

// AdditionalFieldsCleared reports if the "additionalFields" edge to the AdditionalField entity was cleared.
func (m *PasswordMutation) AdditionalFieldsCleared() bool {
	return m.clearedadditionalFields
}

// RemoveAdditionalFieldIDs removes the "additionalFields" edge to the AdditionalField entity by IDs.
func (m *PasswordMutation) RemoveAdditionalFieldIDs(ids ...uuid.UUID) {
	if m.removedadditionalFields == nil {
		m.removedadditionalFields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.additionalFields, ids[i])
		m.removedadditionalFields[ids[i]] = struct{}{}
	}
}

// RemovedAdditionalFields returns the removed IDs of the "additionalFields" edge to the AdditionalField entity.
func (m *PasswordMutation) RemovedAdditionalFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedadditionalFields {
		ids = append(ids, id)
	}
	return
}

// AdditionalFieldsIDs returns the "additionalFields" edge IDs in the mutation.
func (m *PasswordMutation) AdditionalFieldsIDs() (ids []uuid.UUID) {
	for id := range m.additionalFields {
		ids = append(ids, id)
	}
	return
}

// ResetAdditionalFields resets all changes to the "additionalFields" edge.
func (m *PasswordMutation) ResetAdditionalFields() {
	m.additionalFields = nil
	m.clearedadditionalFields = false
	m.removedadditionalFields = nil
}

// AddURLIDs adds the "urls" edge to the Url entity by ids.
func (m *PasswordMutation) AddURLIDs(ids ...uuid.UUID) {
	if m.urls == nil {
		m.urls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.urls[ids[i]] = struct{}{}
	}
}

// ClearUrls clears the "urls" edge to the Url entity.
func (m *PasswordMutation) ClearUrls() {
	m.clearedurls = true
}

// UrlsCleared reports if the "urls" edge to the Url entity was cleared.
func (m *PasswordMutation) UrlsCleared() bool {
	return m.clearedurls
}

// RemoveURLIDs removes the "urls" edge to the Url entity by IDs.
func (m *PasswordMutation) RemoveURLIDs(ids ...uuid.UUID) {
	if m.removedurls == nil {
		m.removedurls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.urls, ids[i])
		m.removedurls[ids[i]] = struct{}{}
	}
}

// RemovedUrls returns the removed IDs of the "urls" edge to the Url entity.
func (m *PasswordMutation) RemovedUrlsIDs() (ids []uuid.UUID) {
	for id := range m.removedurls {
		ids = append(ids, id)
	}
	return
}

// UrlsIDs returns the "urls" edge IDs in the mutation.
func (m *PasswordMutation) UrlsIDs() (ids []uuid.UUID) {
	for id := range m.urls {
		ids = append(ids, id)
	}
	return
}

// ResetUrls resets all changes to the "urls" edge.
func (m *PasswordMutation) ResetUrls() {
	m.urls = nil
	m.clearedurls = false
	m.removedurls = nil
}

// Where appends a list predicates to the PasswordMutation builder.
func (m *PasswordMutation) Where(ps ...predicate.Password) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Password, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Password).
func (m *PasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, password.FieldName)
	}
	if m.nameIv != nil {
		fields = append(fields, password.FieldNameIv)
	}
	if m.username != nil {
		fields = append(fields, password.FieldUsername)
	}
	if m.usernameIv != nil {
		fields = append(fields, password.FieldUsernameIv)
	}
	if m.password != nil {
		fields = append(fields, password.FieldPassword)
	}
	if m.passwordIv != nil {
		fields = append(fields, password.FieldPasswordIv)
	}
	if m.colour != nil {
		fields = append(fields, password.FieldColour)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case password.FieldName:
		return m.Name()
	case password.FieldNameIv:
		return m.NameIv()
	case password.FieldUsername:
		return m.Username()
	case password.FieldUsernameIv:
		return m.UsernameIv()
	case password.FieldPassword:
		return m.Password()
	case password.FieldPasswordIv:
		return m.PasswordIv()
	case password.FieldColour:
		return m.Colour()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case password.FieldName:
		return m.OldName(ctx)
	case password.FieldNameIv:
		return m.OldNameIv(ctx)
	case password.FieldUsername:
		return m.OldUsername(ctx)
	case password.FieldUsernameIv:
		return m.OldUsernameIv(ctx)
	case password.FieldPassword:
		return m.OldPassword(ctx)
	case password.FieldPasswordIv:
		return m.OldPasswordIv(ctx)
	case password.FieldColour:
		return m.OldColour(ctx)
	}
	return nil, fmt.Errorf("unknown Password field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case password.FieldName:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case password.FieldNameIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameIv(v)
		return nil
	case password.FieldUsername:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case password.FieldUsernameIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsernameIv(v)
		return nil
	case password.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case password.FieldPasswordIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordIv(v)
		return nil
	case password.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Password numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(password.FieldColour) {
		fields = append(fields, password.FieldColour)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordMutation) ClearField(name string) error {
	switch name {
	case password.FieldColour:
		m.ClearColour()
		return nil
	}
	return fmt.Errorf("unknown Password nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordMutation) ResetField(name string) error {
	switch name {
	case password.FieldName:
		m.ResetName()
		return nil
	case password.FieldNameIv:
		m.ResetNameIv()
		return nil
	case password.FieldUsername:
		m.ResetUsername()
		return nil
	case password.FieldUsernameIv:
		m.ResetUsernameIv()
		return nil
	case password.FieldPassword:
		m.ResetPassword()
		return nil
	case password.FieldPasswordIv:
		m.ResetPasswordIv()
		return nil
	case password.FieldColour:
		m.ResetColour()
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.additionalFields != nil {
		edges = append(edges, password.EdgeAdditionalFields)
	}
	if m.urls != nil {
		edges = append(edges, password.EdgeUrls)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case password.EdgeAdditionalFields:
		ids := make([]ent.Value, 0, len(m.additionalFields))
		for id := range m.additionalFields {
			ids = append(ids, id)
		}
		return ids
	case password.EdgeUrls:
		ids := make([]ent.Value, 0, len(m.urls))
		for id := range m.urls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedadditionalFields != nil {
		edges = append(edges, password.EdgeAdditionalFields)
	}
	if m.removedurls != nil {
		edges = append(edges, password.EdgeUrls)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case password.EdgeAdditionalFields:
		ids := make([]ent.Value, 0, len(m.removedadditionalFields))
		for id := range m.removedadditionalFields {
			ids = append(ids, id)
		}
		return ids
	case password.EdgeUrls:
		ids := make([]ent.Value, 0, len(m.removedurls))
		for id := range m.removedurls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedadditionalFields {
		edges = append(edges, password.EdgeAdditionalFields)
	}
	if m.clearedurls {
		edges = append(edges, password.EdgeUrls)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordMutation) EdgeCleared(name string) bool {
	switch name {
	case password.EdgeAdditionalFields:
		return m.clearedadditionalFields
	case password.EdgeUrls:
		return m.clearedurls
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Password unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordMutation) ResetEdge(name string) error {
	switch name {
	case password.EdgeAdditionalFields:
		m.ResetAdditionalFields()
		return nil
	case password.EdgeUrls:
		m.ResetUrls()
		return nil
	}
	return fmt.Errorf("unknown Password edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	n             *[]byte
	e             *int
	adde          *int
	expiry        *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetN sets the "n" field.
func (m *SessionMutation) SetN(b []byte) {
	m.n = &b
}

// N returns the value of the "n" field in the mutation.
func (m *SessionMutation) N() (r []byte, exists bool) {
	v := m.n
	if v == nil {
		return
	}
	return *v, true
}

// OldN returns the old "n" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldN(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldN: %w", err)
	}
	return oldValue.N, nil
}

// ResetN resets all changes to the "n" field.
func (m *SessionMutation) ResetN() {
	m.n = nil
}

// SetE sets the "e" field.
func (m *SessionMutation) SetE(i int) {
	m.e = &i
	m.adde = nil
}

// E returns the value of the "e" field in the mutation.
func (m *SessionMutation) E() (r int, exists bool) {
	v := m.e
	if v == nil {
		return
	}
	return *v, true
}

// OldE returns the old "e" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldE(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldE is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldE: %w", err)
	}
	return oldValue.E, nil
}

// AddE adds i to the "e" field.
func (m *SessionMutation) AddE(i int) {
	if m.adde != nil {
		*m.adde += i
	} else {
		m.adde = &i
	}
}

// AddedE returns the value that was added to the "e" field in this mutation.
func (m *SessionMutation) AddedE() (r int, exists bool) {
	v := m.adde
	if v == nil {
		return
	}
	return *v, true
}

// ResetE resets all changes to the "e" field.
func (m *SessionMutation) ResetE() {
	m.e = nil
	m.adde = nil
}

// SetExpiry sets the "expiry" field.
func (m *SessionMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *SessionMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *SessionMutation) ResetExpiry() {
	m.expiry = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SessionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SessionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.n != nil {
		fields = append(fields, session.FieldN)
	}
	if m.e != nil {
		fields = append(fields, session.FieldE)
	}
	if m.expiry != nil {
		fields = append(fields, session.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldN:
		return m.N()
	case session.FieldE:
		return m.E()
	case session.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldN:
		return m.OldN(ctx)
	case session.FieldE:
		return m.OldE(ctx)
	case session.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldN:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetN(v)
		return nil
	case session.FieldE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetE(v)
		return nil
	case session.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.adde != nil {
		fields = append(fields, session.FieldE)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldE:
		return m.AddedE()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddE(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldN:
		m.ResetN()
		return nil
	case session.FieldE:
		m.ResetE()
		return nil
	case session.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// URLMutation represents an operation that mutates the Url nodes in the graph.
type URLMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	url             *[]byte
	urlIv           *[]byte
	clearedFields   map[string]struct{}
	password        *uuid.UUID
	clearedpassword bool
	done            bool
	oldValue        func(context.Context) (*Url, error)
	predicates      []predicate.Url
}

var _ ent.Mutation = (*URLMutation)(nil)

// urlOption allows management of the mutation configuration using functional options.
type urlOption func(*URLMutation)

// newURLMutation creates new mutation for the Url entity.
func newURLMutation(c config, op Op, opts ...urlOption) *URLMutation {
	m := &URLMutation{
		config:        c,
		op:            op,
		typ:           TypeURL,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUrlID sets the ID field of the mutation.
func withUrlID(id uuid.UUID) urlOption {
	return func(m *URLMutation) {
		var (
			err   error
			once  sync.Once
			value *Url
		)
		m.oldValue = func(ctx context.Context) (*Url, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Url.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUrl sets the old Url of the mutation.
func withUrl(node *Url) urlOption {
	return func(m *URLMutation) {
		m.oldValue = func(context.Context) (*Url, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m URLMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m URLMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Url entities.
func (m *URLMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *URLMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *URLMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Url.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *URLMutation) SetURL(b []byte) {
	m.url = &b
}

// URL returns the value of the "url" field in the mutation.
func (m *URLMutation) URL() (r []byte, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Url entity.
// If the Url object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldURL(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *URLMutation) ResetURL() {
	m.url = nil
}

// SetUrlIv sets the "urlIv" field.
func (m *URLMutation) SetUrlIv(b []byte) {
	m.urlIv = &b
}

// UrlIv returns the value of the "urlIv" field in the mutation.
func (m *URLMutation) UrlIv() (r []byte, exists bool) {
	v := m.urlIv
	if v == nil {
		return
	}
	return *v, true
}

// OldUrlIv returns the old "urlIv" field's value of the Url entity.
// If the Url object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldUrlIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrlIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrlIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrlIv: %w", err)
	}
	return oldValue.UrlIv, nil
}

// ResetUrlIv resets all changes to the "urlIv" field.
func (m *URLMutation) ResetUrlIv() {
	m.urlIv = nil
}

// SetPasswordID sets the "password" edge to the Password entity by id.
func (m *URLMutation) SetPasswordID(id uuid.UUID) {
	m.password = &id
}

// ClearPassword clears the "password" edge to the Password entity.
func (m *URLMutation) ClearPassword() {
	m.clearedpassword = true
}

// PasswordCleared reports if the "password" edge to the Password entity was cleared.
func (m *URLMutation) PasswordCleared() bool {
	return m.clearedpassword
}

// PasswordID returns the "password" edge ID in the mutation.
func (m *URLMutation) PasswordID() (id uuid.UUID, exists bool) {
	if m.password != nil {
		return *m.password, true
	}
	return
}

// PasswordIDs returns the "password" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PasswordID instead. It exists only for internal usage by the builders.
func (m *URLMutation) PasswordIDs() (ids []uuid.UUID) {
	if id := m.password; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPassword resets all changes to the "password" edge.
func (m *URLMutation) ResetPassword() {
	m.password = nil
	m.clearedpassword = false
}

// Where appends a list predicates to the URLMutation builder.
func (m *URLMutation) Where(ps ...predicate.Url) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the URLMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *URLMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Url, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *URLMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *URLMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Url).
func (m *URLMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *URLMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.url != nil {
		fields = append(fields, url.FieldURL)
	}
	if m.urlIv != nil {
		fields = append(fields, url.FieldUrlIv)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *URLMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case url.FieldURL:
		return m.URL()
	case url.FieldUrlIv:
		return m.UrlIv()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *URLMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case url.FieldURL:
		return m.OldURL(ctx)
	case url.FieldUrlIv:
		return m.OldUrlIv(ctx)
	}
	return nil, fmt.Errorf("unknown Url field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLMutation) SetField(name string, value ent.Value) error {
	switch name {
	case url.FieldURL:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case url.FieldUrlIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrlIv(v)
		return nil
	}
	return fmt.Errorf("unknown Url field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *URLMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *URLMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Url numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *URLMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *URLMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *URLMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Url nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *URLMutation) ResetField(name string) error {
	switch name {
	case url.FieldURL:
		m.ResetURL()
		return nil
	case url.FieldUrlIv:
		m.ResetUrlIv()
		return nil
	}
	return fmt.Errorf("unknown Url field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *URLMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.password != nil {
		edges = append(edges, url.EdgePassword)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *URLMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case url.EdgePassword:
		if id := m.password; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *URLMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *URLMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *URLMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpassword {
		edges = append(edges, url.EdgePassword)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *URLMutation) EdgeCleared(name string) bool {
	switch name {
	case url.EdgePassword:
		return m.clearedpassword
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *URLMutation) ClearEdge(name string) error {
	switch name {
	case url.EdgePassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Url unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *URLMutation) ResetEdge(name string) error {
	switch name {
	case url.EdgePassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Url edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	email                      *string
	strengthenedMasterHash     *[]byte
	strengthenedMasterHashSalt *[]byte
	protectedDatabaseKey       *[]byte
	protectedDatabaseKeyIv     *[]byte
	default2FA                 *user.Default2FA
	verified                   *bool
	clearedFields              map[string]struct{}
	emailChallenges            map[uuid.UUID]struct{}
	removedemailChallenges     map[uuid.UUID]struct{}
	clearedemailChallenges     bool
	webauthnCredentials        map[uuid.UUID]struct{}
	removedwebauthnCredentials map[uuid.UUID]struct{}
	clearedwebauthnCredentials bool
	webauthnChallenges         map[uuid.UUID]struct{}
	removedwebauthnChallenges  map[uuid.UUID]struct{}
	clearedwebauthnChallenges  bool
	sessions                   map[uuid.UUID]struct{}
	removedsessions            map[uuid.UUID]struct{}
	clearedsessions            bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStrengthenedMasterHash sets the "strengthenedMasterHash" field.
func (m *UserMutation) SetStrengthenedMasterHash(b []byte) {
	m.strengthenedMasterHash = &b
}

// StrengthenedMasterHash returns the value of the "strengthenedMasterHash" field in the mutation.
func (m *UserMutation) StrengthenedMasterHash() (r []byte, exists bool) {
	v := m.strengthenedMasterHash
	if v == nil {
		return
	}
	return *v, true
}

// OldStrengthenedMasterHash returns the old "strengthenedMasterHash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStrengthenedMasterHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrengthenedMasterHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrengthenedMasterHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrengthenedMasterHash: %w", err)
	}
	return oldValue.StrengthenedMasterHash, nil
}

// ResetStrengthenedMasterHash resets all changes to the "strengthenedMasterHash" field.
func (m *UserMutation) ResetStrengthenedMasterHash() {
	m.strengthenedMasterHash = nil
}

// SetStrengthenedMasterHashSalt sets the "strengthenedMasterHashSalt" field.
func (m *UserMutation) SetStrengthenedMasterHashSalt(b []byte) {
	m.strengthenedMasterHashSalt = &b
}

// StrengthenedMasterHashSalt returns the value of the "strengthenedMasterHashSalt" field in the mutation.
func (m *UserMutation) StrengthenedMasterHashSalt() (r []byte, exists bool) {
	v := m.strengthenedMasterHashSalt
	if v == nil {
		return
	}
	return *v, true
}

// OldStrengthenedMasterHashSalt returns the old "strengthenedMasterHashSalt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStrengthenedMasterHashSalt(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrengthenedMasterHashSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrengthenedMasterHashSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrengthenedMasterHashSalt: %w", err)
	}
	return oldValue.StrengthenedMasterHashSalt, nil
}

// ResetStrengthenedMasterHashSalt resets all changes to the "strengthenedMasterHashSalt" field.
func (m *UserMutation) ResetStrengthenedMasterHashSalt() {
	m.strengthenedMasterHashSalt = nil
}

// SetProtectedDatabaseKey sets the "protectedDatabaseKey" field.
func (m *UserMutation) SetProtectedDatabaseKey(b []byte) {
	m.protectedDatabaseKey = &b
}

// ProtectedDatabaseKey returns the value of the "protectedDatabaseKey" field in the mutation.
func (m *UserMutation) ProtectedDatabaseKey() (r []byte, exists bool) {
	v := m.protectedDatabaseKey
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedDatabaseKey returns the old "protectedDatabaseKey" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProtectedDatabaseKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedDatabaseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedDatabaseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedDatabaseKey: %w", err)
	}
	return oldValue.ProtectedDatabaseKey, nil
}

// ResetProtectedDatabaseKey resets all changes to the "protectedDatabaseKey" field.
func (m *UserMutation) ResetProtectedDatabaseKey() {
	m.protectedDatabaseKey = nil
}

// SetProtectedDatabaseKeyIv sets the "protectedDatabaseKeyIv" field.
func (m *UserMutation) SetProtectedDatabaseKeyIv(b []byte) {
	m.protectedDatabaseKeyIv = &b
}

// ProtectedDatabaseKeyIv returns the value of the "protectedDatabaseKeyIv" field in the mutation.
func (m *UserMutation) ProtectedDatabaseKeyIv() (r []byte, exists bool) {
	v := m.protectedDatabaseKeyIv
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedDatabaseKeyIv returns the old "protectedDatabaseKeyIv" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProtectedDatabaseKeyIv(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedDatabaseKeyIv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedDatabaseKeyIv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedDatabaseKeyIv: %w", err)
	}
	return oldValue.ProtectedDatabaseKeyIv, nil
}

// ResetProtectedDatabaseKeyIv resets all changes to the "protectedDatabaseKeyIv" field.
func (m *UserMutation) ResetProtectedDatabaseKeyIv() {
	m.protectedDatabaseKeyIv = nil
}

// SetDefault2FA sets the "default2FA" field.
func (m *UserMutation) SetDefault2FA(u user.Default2FA) {
	m.default2FA = &u
}

// Default2FA returns the value of the "default2FA" field in the mutation.
func (m *UserMutation) Default2FA() (r user.Default2FA, exists bool) {
	v := m.default2FA
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault2FA returns the old "default2FA" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDefault2FA(ctx context.Context) (v user.Default2FA, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault2FA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault2FA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault2FA: %w", err)
	}
	return oldValue.Default2FA, nil
}

// ResetDefault2FA resets all changes to the "default2FA" field.
func (m *UserMutation) ResetDefault2FA() {
	m.default2FA = nil
}

// SetVerified sets the "verified" field.
func (m *UserMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *UserMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *UserMutation) ResetVerified() {
	m.verified = nil
}

// AddEmailChallengeIDs adds the "emailChallenges" edge to the EmailChallenge entity by ids.
func (m *UserMutation) AddEmailChallengeIDs(ids ...uuid.UUID) {
	if m.emailChallenges == nil {
		m.emailChallenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.emailChallenges[ids[i]] = struct{}{}
	}
}

// ClearEmailChallenges clears the "emailChallenges" edge to the EmailChallenge entity.
func (m *UserMutation) ClearEmailChallenges() {
	m.clearedemailChallenges = true
}

// EmailChallengesCleared reports if the "emailChallenges" edge to the EmailChallenge entity was cleared.
func (m *UserMutation) EmailChallengesCleared() bool {
	return m.clearedemailChallenges
}

// RemoveEmailChallengeIDs removes the "emailChallenges" edge to the EmailChallenge entity by IDs.
func (m *UserMutation) RemoveEmailChallengeIDs(ids ...uuid.UUID) {
	if m.removedemailChallenges == nil {
		m.removedemailChallenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.emailChallenges, ids[i])
		m.removedemailChallenges[ids[i]] = struct{}{}
	}
}

// RemovedEmailChallenges returns the removed IDs of the "emailChallenges" edge to the EmailChallenge entity.
func (m *UserMutation) RemovedEmailChallengesIDs() (ids []uuid.UUID) {
	for id := range m.removedemailChallenges {
		ids = append(ids, id)
	}
	return
}

// EmailChallengesIDs returns the "emailChallenges" edge IDs in the mutation.
func (m *UserMutation) EmailChallengesIDs() (ids []uuid.UUID) {
	for id := range m.emailChallenges {
		ids = append(ids, id)
	}
	return
}

// ResetEmailChallenges resets all changes to the "emailChallenges" edge.
func (m *UserMutation) ResetEmailChallenges() {
	m.emailChallenges = nil
	m.clearedemailChallenges = false
	m.removedemailChallenges = nil
}

// AddWebauthnCredentialIDs adds the "webauthnCredentials" edge to the WebAuthnCredential entity by ids.
func (m *UserMutation) AddWebauthnCredentialIDs(ids ...uuid.UUID) {
	if m.webauthnCredentials == nil {
		m.webauthnCredentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.webauthnCredentials[ids[i]] = struct{}{}
	}
}

// ClearWebauthnCredentials clears the "webauthnCredentials" edge to the WebAuthnCredential entity.
func (m *UserMutation) ClearWebauthnCredentials() {
	m.clearedwebauthnCredentials = true
}

// WebauthnCredentialsCleared reports if the "webauthnCredentials" edge to the WebAuthnCredential entity was cleared.
func (m *UserMutation) WebauthnCredentialsCleared() bool {
	return m.clearedwebauthnCredentials
}

// RemoveWebauthnCredentialIDs removes the "webauthnCredentials" edge to the WebAuthnCredential entity by IDs.
func (m *UserMutation) RemoveWebauthnCredentialIDs(ids ...uuid.UUID) {
	if m.removedwebauthnCredentials == nil {
		m.removedwebauthnCredentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.webauthnCredentials, ids[i])
		m.removedwebauthnCredentials[ids[i]] = struct{}{}
	}
}

// RemovedWebauthnCredentials returns the removed IDs of the "webauthnCredentials" edge to the WebAuthnCredential entity.
func (m *UserMutation) RemovedWebauthnCredentialsIDs() (ids []uuid.UUID) {
	for id := range m.removedwebauthnCredentials {
		ids = append(ids, id)
	}
	return
}

// WebauthnCredentialsIDs returns the "webauthnCredentials" edge IDs in the mutation.
func (m *UserMutation) WebauthnCredentialsIDs() (ids []uuid.UUID) {
	for id := range m.webauthnCredentials {
		ids = append(ids, id)
	}
	return
}

// ResetWebauthnCredentials resets all changes to the "webauthnCredentials" edge.
func (m *UserMutation) ResetWebauthnCredentials() {
	m.webauthnCredentials = nil
	m.clearedwebauthnCredentials = false
	m.removedwebauthnCredentials = nil
}

// AddWebauthnChallengeIDs adds the "webauthnChallenges" edge to the WebAuthnChallenge entity by ids.
func (m *UserMutation) AddWebauthnChallengeIDs(ids ...uuid.UUID) {
	if m.webauthnChallenges == nil {
		m.webauthnChallenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.webauthnChallenges[ids[i]] = struct{}{}
	}
}

// ClearWebauthnChallenges clears the "webauthnChallenges" edge to the WebAuthnChallenge entity.
func (m *UserMutation) ClearWebauthnChallenges() {
	m.clearedwebauthnChallenges = true
}

// WebauthnChallengesCleared reports if the "webauthnChallenges" edge to the WebAuthnChallenge entity was cleared.
func (m *UserMutation) WebauthnChallengesCleared() bool {
	return m.clearedwebauthnChallenges
}

// RemoveWebauthnChallengeIDs removes the "webauthnChallenges" edge to the WebAuthnChallenge entity by IDs.
func (m *UserMutation) RemoveWebauthnChallengeIDs(ids ...uuid.UUID) {
	if m.removedwebauthnChallenges == nil {
		m.removedwebauthnChallenges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.webauthnChallenges, ids[i])
		m.removedwebauthnChallenges[ids[i]] = struct{}{}
	}
}

// RemovedWebauthnChallenges returns the removed IDs of the "webauthnChallenges" edge to the WebAuthnChallenge entity.
func (m *UserMutation) RemovedWebauthnChallengesIDs() (ids []uuid.UUID) {
	for id := range m.removedwebauthnChallenges {
		ids = append(ids, id)
	}
	return
}

// WebauthnChallengesIDs returns the "webauthnChallenges" edge IDs in the mutation.
func (m *UserMutation) WebauthnChallengesIDs() (ids []uuid.UUID) {
	for id := range m.webauthnChallenges {
		ids = append(ids, id)
	}
	return
}

// ResetWebauthnChallenges resets all changes to the "webauthnChallenges" edge.
func (m *UserMutation) ResetWebauthnChallenges() {
	m.webauthnChallenges = nil
	m.clearedwebauthnChallenges = false
	m.removedwebauthnChallenges = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.strengthenedMasterHash != nil {
		fields = append(fields, user.FieldStrengthenedMasterHash)
	}
	if m.strengthenedMasterHashSalt != nil {
		fields = append(fields, user.FieldStrengthenedMasterHashSalt)
	}
	if m.protectedDatabaseKey != nil {
		fields = append(fields, user.FieldProtectedDatabaseKey)
	}
	if m.protectedDatabaseKeyIv != nil {
		fields = append(fields, user.FieldProtectedDatabaseKeyIv)
	}
	if m.default2FA != nil {
		fields = append(fields, user.FieldDefault2FA)
	}
	if m.verified != nil {
		fields = append(fields, user.FieldVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldStrengthenedMasterHash:
		return m.StrengthenedMasterHash()
	case user.FieldStrengthenedMasterHashSalt:
		return m.StrengthenedMasterHashSalt()
	case user.FieldProtectedDatabaseKey:
		return m.ProtectedDatabaseKey()
	case user.FieldProtectedDatabaseKeyIv:
		return m.ProtectedDatabaseKeyIv()
	case user.FieldDefault2FA:
		return m.Default2FA()
	case user.FieldVerified:
		return m.Verified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStrengthenedMasterHash:
		return m.OldStrengthenedMasterHash(ctx)
	case user.FieldStrengthenedMasterHashSalt:
		return m.OldStrengthenedMasterHashSalt(ctx)
	case user.FieldProtectedDatabaseKey:
		return m.OldProtectedDatabaseKey(ctx)
	case user.FieldProtectedDatabaseKeyIv:
		return m.OldProtectedDatabaseKeyIv(ctx)
	case user.FieldDefault2FA:
		return m.OldDefault2FA(ctx)
	case user.FieldVerified:
		return m.OldVerified(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStrengthenedMasterHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrengthenedMasterHash(v)
		return nil
	case user.FieldStrengthenedMasterHashSalt:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrengthenedMasterHashSalt(v)
		return nil
	case user.FieldProtectedDatabaseKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedDatabaseKey(v)
		return nil
	case user.FieldProtectedDatabaseKeyIv:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedDatabaseKeyIv(v)
		return nil
	case user.FieldDefault2FA:
		v, ok := value.(user.Default2FA)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault2FA(v)
		return nil
	case user.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStrengthenedMasterHash:
		m.ResetStrengthenedMasterHash()
		return nil
	case user.FieldStrengthenedMasterHashSalt:
		m.ResetStrengthenedMasterHashSalt()
		return nil
	case user.FieldProtectedDatabaseKey:
		m.ResetProtectedDatabaseKey()
		return nil
	case user.FieldProtectedDatabaseKeyIv:
		m.ResetProtectedDatabaseKeyIv()
		return nil
	case user.FieldDefault2FA:
		m.ResetDefault2FA()
		return nil
	case user.FieldVerified:
		m.ResetVerified()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.emailChallenges != nil {
		edges = append(edges, user.EdgeEmailChallenges)
	}
	if m.webauthnCredentials != nil {
		edges = append(edges, user.EdgeWebauthnCredentials)
	}
	if m.webauthnChallenges != nil {
		edges = append(edges, user.EdgeWebauthnChallenges)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEmailChallenges:
		ids := make([]ent.Value, 0, len(m.emailChallenges))
		for id := range m.emailChallenges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthnCredentials:
		ids := make([]ent.Value, 0, len(m.webauthnCredentials))
		for id := range m.webauthnCredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthnChallenges:
		ids := make([]ent.Value, 0, len(m.webauthnChallenges))
		for id := range m.webauthnChallenges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedemailChallenges != nil {
		edges = append(edges, user.EdgeEmailChallenges)
	}
	if m.removedwebauthnCredentials != nil {
		edges = append(edges, user.EdgeWebauthnCredentials)
	}
	if m.removedwebauthnChallenges != nil {
		edges = append(edges, user.EdgeWebauthnChallenges)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEmailChallenges:
		ids := make([]ent.Value, 0, len(m.removedemailChallenges))
		for id := range m.removedemailChallenges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthnCredentials:
		ids := make([]ent.Value, 0, len(m.removedwebauthnCredentials))
		for id := range m.removedwebauthnCredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthnChallenges:
		ids := make([]ent.Value, 0, len(m.removedwebauthnChallenges))
		for id := range m.removedwebauthnChallenges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedemailChallenges {
		edges = append(edges, user.EdgeEmailChallenges)
	}
	if m.clearedwebauthnCredentials {
		edges = append(edges, user.EdgeWebauthnCredentials)
	}
	if m.clearedwebauthnChallenges {
		edges = append(edges, user.EdgeWebauthnChallenges)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeEmailChallenges:
		return m.clearedemailChallenges
	case user.EdgeWebauthnCredentials:
		return m.clearedwebauthnCredentials
	case user.EdgeWebauthnChallenges:
		return m.clearedwebauthnChallenges
	case user.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeEmailChallenges:
		m.ResetEmailChallenges()
		return nil
	case user.EdgeWebauthnCredentials:
		m.ResetWebauthnCredentials()
		return nil
	case user.EdgeWebauthnChallenges:
		m.ResetWebauthnChallenges()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WebAuthnChallengeMutation represents an operation that mutates the WebAuthnChallenge nodes in the graph.
type WebAuthnChallengeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	challenge                  *string
	userId                     *[]byte
	allowedCredentialIds       *[][]uint8
	appendallowedCredentialIds [][]uint8
	userVerification           *string
	extensions                 *map[string]interface{}
	clearedFields              map[string]struct{}
	user                       *uuid.UUID
	cleareduser                bool
	done                       bool
	oldValue                   func(context.Context) (*WebAuthnChallenge, error)
	predicates                 []predicate.WebAuthnChallenge
}

var _ ent.Mutation = (*WebAuthnChallengeMutation)(nil)

// webauthnchallengeOption allows management of the mutation configuration using functional options.
type webauthnchallengeOption func(*WebAuthnChallengeMutation)

// newWebAuthnChallengeMutation creates new mutation for the WebAuthnChallenge entity.
func newWebAuthnChallengeMutation(c config, op Op, opts ...webauthnchallengeOption) *WebAuthnChallengeMutation {
	m := &WebAuthnChallengeMutation{
		config:        c,
		op:            op,
		typ:           TypeWebAuthnChallenge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebAuthnChallengeID sets the ID field of the mutation.
func withWebAuthnChallengeID(id uuid.UUID) webauthnchallengeOption {
	return func(m *WebAuthnChallengeMutation) {
		var (
			err   error
			once  sync.Once
			value *WebAuthnChallenge
		)
		m.oldValue = func(ctx context.Context) (*WebAuthnChallenge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebAuthnChallenge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebAuthnChallenge sets the old WebAuthnChallenge of the mutation.
func withWebAuthnChallenge(node *WebAuthnChallenge) webauthnchallengeOption {
	return func(m *WebAuthnChallengeMutation) {
		m.oldValue = func(context.Context) (*WebAuthnChallenge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebAuthnChallengeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebAuthnChallengeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebAuthnChallenge entities.
func (m *WebAuthnChallengeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebAuthnChallengeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebAuthnChallengeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebAuthnChallenge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChallenge sets the "challenge" field.
func (m *WebAuthnChallengeMutation) SetChallenge(s string) {
	m.challenge = &s
}

// Challenge returns the value of the "challenge" field in the mutation.
func (m *WebAuthnChallengeMutation) Challenge() (r string, exists bool) {
	v := m.challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldChallenge returns the old "challenge" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallenge: %w", err)
	}
	return oldValue.Challenge, nil
}

// ClearChallenge clears the value of the "challenge" field.
func (m *WebAuthnChallengeMutation) ClearChallenge() {
	m.challenge = nil
	m.clearedFields[webauthnchallenge.FieldChallenge] = struct{}{}
}

// ChallengeCleared returns if the "challenge" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) ChallengeCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldChallenge]
	return ok
}

// ResetChallenge resets all changes to the "challenge" field.
func (m *WebAuthnChallengeMutation) ResetChallenge() {
	m.challenge = nil
	delete(m.clearedFields, webauthnchallenge.FieldChallenge)
}

// SetUserId sets the "userId" field.
func (m *WebAuthnChallengeMutation) SetUserId(b []byte) {
	m.userId = &b
}

// UserId returns the value of the "userId" field in the mutation.
func (m *WebAuthnChallengeMutation) UserId() (r []byte, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldUserId(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "userId" field.
func (m *WebAuthnChallengeMutation) ClearUserId() {
	m.userId = nil
	m.clearedFields[webauthnchallenge.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *WebAuthnChallengeMutation) ResetUserId() {
	m.userId = nil
	delete(m.clearedFields, webauthnchallenge.FieldUserId)
}

// SetAllowedCredentialIds sets the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) SetAllowedCredentialIds(u [][]uint8) {
	m.allowedCredentialIds = &u
	m.appendallowedCredentialIds = nil
}

// AllowedCredentialIds returns the value of the "allowedCredentialIds" field in the mutation.
func (m *WebAuthnChallengeMutation) AllowedCredentialIds() (r [][]uint8, exists bool) {
	v := m.allowedCredentialIds
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedCredentialIds returns the old "allowedCredentialIds" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldAllowedCredentialIds(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedCredentialIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedCredentialIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedCredentialIds: %w", err)
	}
	return oldValue.AllowedCredentialIds, nil
}

// AppendAllowedCredentialIds adds u to the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) AppendAllowedCredentialIds(u [][]uint8) {
	m.appendallowedCredentialIds = append(m.appendallowedCredentialIds, u...)
}

// AppendedAllowedCredentialIds returns the list of values that were appended to the "allowedCredentialIds" field in this mutation.
func (m *WebAuthnChallengeMutation) AppendedAllowedCredentialIds() ([][]uint8, bool) {
	if len(m.appendallowedCredentialIds) == 0 {
		return nil, false
	}
	return m.appendallowedCredentialIds, true
}

// ClearAllowedCredentialIds clears the value of the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) ClearAllowedCredentialIds() {
	m.allowedCredentialIds = nil
	m.appendallowedCredentialIds = nil
	m.clearedFields[webauthnchallenge.FieldAllowedCredentialIds] = struct{}{}
}

// AllowedCredentialIdsCleared returns if the "allowedCredentialIds" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) AllowedCredentialIdsCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldAllowedCredentialIds]
	return ok
}

// ResetAllowedCredentialIds resets all changes to the "allowedCredentialIds" field.
func (m *WebAuthnChallengeMutation) ResetAllowedCredentialIds() {
	m.allowedCredentialIds = nil
	m.appendallowedCredentialIds = nil
	delete(m.clearedFields, webauthnchallenge.FieldAllowedCredentialIds)
}

// SetUserVerification sets the "userVerification" field.
func (m *WebAuthnChallengeMutation) SetUserVerification(s string) {
	m.userVerification = &s
}

// UserVerification returns the value of the "userVerification" field in the mutation.
func (m *WebAuthnChallengeMutation) UserVerification() (r string, exists bool) {
	v := m.userVerification
	if v == nil {
		return
	}
	return *v, true
}

// OldUserVerification returns the old "userVerification" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldUserVerification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserVerification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserVerification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserVerification: %w", err)
	}
	return oldValue.UserVerification, nil
}

// ClearUserVerification clears the value of the "userVerification" field.
func (m *WebAuthnChallengeMutation) ClearUserVerification() {
	m.userVerification = nil
	m.clearedFields[webauthnchallenge.FieldUserVerification] = struct{}{}
}

// UserVerificationCleared returns if the "userVerification" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) UserVerificationCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldUserVerification]
	return ok
}

// ResetUserVerification resets all changes to the "userVerification" field.
func (m *WebAuthnChallengeMutation) ResetUserVerification() {
	m.userVerification = nil
	delete(m.clearedFields, webauthnchallenge.FieldUserVerification)
}

// SetExtensions sets the "extensions" field.
func (m *WebAuthnChallengeMutation) SetExtensions(value map[string]interface{}) {
	m.extensions = &value
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *WebAuthnChallengeMutation) Extensions() (r map[string]interface{}, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the WebAuthnChallenge entity.
// If the WebAuthnChallenge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnChallengeMutation) OldExtensions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ClearExtensions clears the value of the "extensions" field.
func (m *WebAuthnChallengeMutation) ClearExtensions() {
	m.extensions = nil
	m.clearedFields[webauthnchallenge.FieldExtensions] = struct{}{}
}

// ExtensionsCleared returns if the "extensions" field was cleared in this mutation.
func (m *WebAuthnChallengeMutation) ExtensionsCleared() bool {
	_, ok := m.clearedFields[webauthnchallenge.FieldExtensions]
	return ok
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *WebAuthnChallengeMutation) ResetExtensions() {
	m.extensions = nil
	delete(m.clearedFields, webauthnchallenge.FieldExtensions)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WebAuthnChallengeMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WebAuthnChallengeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WebAuthnChallengeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WebAuthnChallengeMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WebAuthnChallengeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WebAuthnChallengeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WebAuthnChallengeMutation builder.
func (m *WebAuthnChallengeMutation) Where(ps ...predicate.WebAuthnChallenge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebAuthnChallengeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebAuthnChallengeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebAuthnChallenge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebAuthnChallengeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebAuthnChallengeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebAuthnChallenge).
func (m *WebAuthnChallengeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebAuthnChallengeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.challenge != nil {
		fields = append(fields, webauthnchallenge.FieldChallenge)
	}
	if m.userId != nil {
		fields = append(fields, webauthnchallenge.FieldUserId)
	}
	if m.allowedCredentialIds != nil {
		fields = append(fields, webauthnchallenge.FieldAllowedCredentialIds)
	}
	if m.userVerification != nil {
		fields = append(fields, webauthnchallenge.FieldUserVerification)
	}
	if m.extensions != nil {
		fields = append(fields, webauthnchallenge.FieldExtensions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebAuthnChallengeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webauthnchallenge.FieldChallenge:
		return m.Challenge()
	case webauthnchallenge.FieldUserId:
		return m.UserId()
	case webauthnchallenge.FieldAllowedCredentialIds:
		return m.AllowedCredentialIds()
	case webauthnchallenge.FieldUserVerification:
		return m.UserVerification()
	case webauthnchallenge.FieldExtensions:
		return m.Extensions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebAuthnChallengeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webauthnchallenge.FieldChallenge:
		return m.OldChallenge(ctx)
	case webauthnchallenge.FieldUserId:
		return m.OldUserId(ctx)
	case webauthnchallenge.FieldAllowedCredentialIds:
		return m.OldAllowedCredentialIds(ctx)
	case webauthnchallenge.FieldUserVerification:
		return m.OldUserVerification(ctx)
	case webauthnchallenge.FieldExtensions:
		return m.OldExtensions(ctx)
	}
	return nil, fmt.Errorf("unknown WebAuthnChallenge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnChallengeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webauthnchallenge.FieldChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallenge(v)
		return nil
	case webauthnchallenge.FieldUserId:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case webauthnchallenge.FieldAllowedCredentialIds:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedCredentialIds(v)
		return nil
	case webauthnchallenge.FieldUserVerification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserVerification(v)
		return nil
	case webauthnchallenge.FieldExtensions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebAuthnChallengeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebAuthnChallengeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnChallengeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WebAuthnChallenge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebAuthnChallengeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webauthnchallenge.FieldChallenge) {
		fields = append(fields, webauthnchallenge.FieldChallenge)
	}
	if m.FieldCleared(webauthnchallenge.FieldUserId) {
		fields = append(fields, webauthnchallenge.FieldUserId)
	}
	if m.FieldCleared(webauthnchallenge.FieldAllowedCredentialIds) {
		fields = append(fields, webauthnchallenge.FieldAllowedCredentialIds)
	}
	if m.FieldCleared(webauthnchallenge.FieldUserVerification) {
		fields = append(fields, webauthnchallenge.FieldUserVerification)
	}
	if m.FieldCleared(webauthnchallenge.FieldExtensions) {
		fields = append(fields, webauthnchallenge.FieldExtensions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebAuthnChallengeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebAuthnChallengeMutation) ClearField(name string) error {
	switch name {
	case webauthnchallenge.FieldChallenge:
		m.ClearChallenge()
		return nil
	case webauthnchallenge.FieldUserId:
		m.ClearUserId()
		return nil
	case webauthnchallenge.FieldAllowedCredentialIds:
		m.ClearAllowedCredentialIds()
		return nil
	case webauthnchallenge.FieldUserVerification:
		m.ClearUserVerification()
		return nil
	case webauthnchallenge.FieldExtensions:
		m.ClearExtensions()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebAuthnChallengeMutation) ResetField(name string) error {
	switch name {
	case webauthnchallenge.FieldChallenge:
		m.ResetChallenge()
		return nil
	case webauthnchallenge.FieldUserId:
		m.ResetUserId()
		return nil
	case webauthnchallenge.FieldAllowedCredentialIds:
		m.ResetAllowedCredentialIds()
		return nil
	case webauthnchallenge.FieldUserVerification:
		m.ResetUserVerification()
		return nil
	case webauthnchallenge.FieldExtensions:
		m.ResetExtensions()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebAuthnChallengeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, webauthnchallenge.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebAuthnChallengeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webauthnchallenge.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebAuthnChallengeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebAuthnChallengeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebAuthnChallengeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, webauthnchallenge.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebAuthnChallengeMutation) EdgeCleared(name string) bool {
	switch name {
	case webauthnchallenge.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebAuthnChallengeMutation) ClearEdge(name string) error {
	switch name {
	case webauthnchallenge.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebAuthnChallengeMutation) ResetEdge(name string) error {
	switch name {
	case webauthnchallenge.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnChallenge edge %s", name)
}

// WebAuthnCredentialMutation represents an operation that mutates the WebAuthnCredential nodes in the graph.
type WebAuthnCredentialMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	createdAt       *time.Time
	credentialId    *[]byte
	publicKey       *[]byte
	attestationType *string
	transport       *[]string
	appendtransport []string
	aaguid          *[]byte
	signCount       *uint32
	addsignCount    *int32
	cloneWarning    *bool
	clearedFields   map[string]struct{}
	user            *uuid.UUID
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*WebAuthnCredential, error)
	predicates      []predicate.WebAuthnCredential
}

var _ ent.Mutation = (*WebAuthnCredentialMutation)(nil)

// webauthncredentialOption allows management of the mutation configuration using functional options.
type webauthncredentialOption func(*WebAuthnCredentialMutation)

// newWebAuthnCredentialMutation creates new mutation for the WebAuthnCredential entity.
func newWebAuthnCredentialMutation(c config, op Op, opts ...webauthncredentialOption) *WebAuthnCredentialMutation {
	m := &WebAuthnCredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeWebAuthnCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebAuthnCredentialID sets the ID field of the mutation.
func withWebAuthnCredentialID(id uuid.UUID) webauthncredentialOption {
	return func(m *WebAuthnCredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *WebAuthnCredential
		)
		m.oldValue = func(ctx context.Context) (*WebAuthnCredential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebAuthnCredential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebAuthnCredential sets the old WebAuthnCredential of the mutation.
func withWebAuthnCredential(node *WebAuthnCredential) webauthncredentialOption {
	return func(m *WebAuthnCredentialMutation) {
		m.oldValue = func(context.Context) (*WebAuthnCredential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebAuthnCredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebAuthnCredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebAuthnCredential entities.
func (m *WebAuthnCredentialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebAuthnCredentialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebAuthnCredentialMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebAuthnCredential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WebAuthnCredentialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebAuthnCredentialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebAuthnCredentialMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *WebAuthnCredentialMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *WebAuthnCredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *WebAuthnCredentialMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetCredentialId sets the "credentialId" field.
func (m *WebAuthnCredentialMutation) SetCredentialId(b []byte) {
	m.credentialId = &b
}

// CredentialId returns the value of the "credentialId" field in the mutation.
func (m *WebAuthnCredentialMutation) CredentialId() (r []byte, exists bool) {
	v := m.credentialId
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialId returns the old "credentialId" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldCredentialId(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialId: %w", err)
	}
	return oldValue.CredentialId, nil
}

// ResetCredentialId resets all changes to the "credentialId" field.
func (m *WebAuthnCredentialMutation) ResetCredentialId() {
	m.credentialId = nil
}

// SetPublicKey sets the "publicKey" field.
func (m *WebAuthnCredentialMutation) SetPublicKey(b []byte) {
	m.publicKey = &b
}

// PublicKey returns the value of the "publicKey" field in the mutation.
func (m *WebAuthnCredentialMutation) PublicKey() (r []byte, exists bool) {
	v := m.publicKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "publicKey" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "publicKey" field.
func (m *WebAuthnCredentialMutation) ResetPublicKey() {
	m.publicKey = nil
}

// SetAttestationType sets the "attestationType" field.
func (m *WebAuthnCredentialMutation) SetAttestationType(s string) {
	m.attestationType = &s
}

// AttestationType returns the value of the "attestationType" field in the mutation.
func (m *WebAuthnCredentialMutation) AttestationType() (r string, exists bool) {
	v := m.attestationType
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestationType returns the old "attestationType" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldAttestationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestationType: %w", err)
	}
	return oldValue.AttestationType, nil
}

// ResetAttestationType resets all changes to the "attestationType" field.
func (m *WebAuthnCredentialMutation) ResetAttestationType() {
	m.attestationType = nil
}

// SetTransport sets the "transport" field.
func (m *WebAuthnCredentialMutation) SetTransport(s []string) {
	m.transport = &s
	m.appendtransport = nil
}

// Transport returns the value of the "transport" field in the mutation.
func (m *WebAuthnCredentialMutation) Transport() (r []string, exists bool) {
	v := m.transport
	if v == nil {
		return
	}
	return *v, true
}

// OldTransport returns the old "transport" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldTransport(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransport: %w", err)
	}
	return oldValue.Transport, nil
}

// AppendTransport adds s to the "transport" field.
func (m *WebAuthnCredentialMutation) AppendTransport(s []string) {
	m.appendtransport = append(m.appendtransport, s...)
}

// AppendedTransport returns the list of values that were appended to the "transport" field in this mutation.
func (m *WebAuthnCredentialMutation) AppendedTransport() ([]string, bool) {
	if len(m.appendtransport) == 0 {
		return nil, false
	}
	return m.appendtransport, true
}

// ResetTransport resets all changes to the "transport" field.
func (m *WebAuthnCredentialMutation) ResetTransport() {
	m.transport = nil
	m.appendtransport = nil
}

// SetAaguid sets the "aaguid" field.
func (m *WebAuthnCredentialMutation) SetAaguid(b []byte) {
	m.aaguid = &b
}

// Aaguid returns the value of the "aaguid" field in the mutation.
func (m *WebAuthnCredentialMutation) Aaguid() (r []byte, exists bool) {
	v := m.aaguid
	if v == nil {
		return
	}
	return *v, true
}

// OldAaguid returns the old "aaguid" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldAaguid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAaguid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAaguid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAaguid: %w", err)
	}
	return oldValue.Aaguid, nil
}

// ResetAaguid resets all changes to the "aaguid" field.
func (m *WebAuthnCredentialMutation) ResetAaguid() {
	m.aaguid = nil
}

// SetSignCount sets the "signCount" field.
func (m *WebAuthnCredentialMutation) SetSignCount(u uint32) {
	m.signCount = &u
	m.addsignCount = nil
}

// SignCount returns the value of the "signCount" field in the mutation.
func (m *WebAuthnCredentialMutation) SignCount() (r uint32, exists bool) {
	v := m.signCount
	if v == nil {
		return
	}
	return *v, true
}

// OldSignCount returns the old "signCount" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldSignCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignCount: %w", err)
	}
	return oldValue.SignCount, nil
}

// AddSignCount adds u to the "signCount" field.
func (m *WebAuthnCredentialMutation) AddSignCount(u int32) {
	if m.addsignCount != nil {
		*m.addsignCount += u
	} else {
		m.addsignCount = &u
	}
}

// AddedSignCount returns the value that was added to the "signCount" field in this mutation.
func (m *WebAuthnCredentialMutation) AddedSignCount() (r int32, exists bool) {
	v := m.addsignCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignCount resets all changes to the "signCount" field.
func (m *WebAuthnCredentialMutation) ResetSignCount() {
	m.signCount = nil
	m.addsignCount = nil
}

// SetCloneWarning sets the "cloneWarning" field.
func (m *WebAuthnCredentialMutation) SetCloneWarning(b bool) {
	m.cloneWarning = &b
}

// CloneWarning returns the value of the "cloneWarning" field in the mutation.
func (m *WebAuthnCredentialMutation) CloneWarning() (r bool, exists bool) {
	v := m.cloneWarning
	if v == nil {
		return
	}
	return *v, true
}

// OldCloneWarning returns the old "cloneWarning" field's value of the WebAuthnCredential entity.
// If the WebAuthnCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebAuthnCredentialMutation) OldCloneWarning(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloneWarning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloneWarning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloneWarning: %w", err)
	}
	return oldValue.CloneWarning, nil
}

// ResetCloneWarning resets all changes to the "cloneWarning" field.
func (m *WebAuthnCredentialMutation) ResetCloneWarning() {
	m.cloneWarning = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WebAuthnCredentialMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WebAuthnCredentialMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WebAuthnCredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WebAuthnCredentialMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WebAuthnCredentialMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WebAuthnCredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WebAuthnCredentialMutation builder.
func (m *WebAuthnCredentialMutation) Where(ps ...predicate.WebAuthnCredential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebAuthnCredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebAuthnCredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebAuthnCredential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebAuthnCredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebAuthnCredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebAuthnCredential).
func (m *WebAuthnCredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebAuthnCredentialMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, webauthncredential.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, webauthncredential.FieldCreatedAt)
	}
	if m.credentialId != nil {
		fields = append(fields, webauthncredential.FieldCredentialId)
	}
	if m.publicKey != nil {
		fields = append(fields, webauthncredential.FieldPublicKey)
	}
	if m.attestationType != nil {
		fields = append(fields, webauthncredential.FieldAttestationType)
	}
	if m.transport != nil {
		fields = append(fields, webauthncredential.FieldTransport)
	}
	if m.aaguid != nil {
		fields = append(fields, webauthncredential.FieldAaguid)
	}
	if m.signCount != nil {
		fields = append(fields, webauthncredential.FieldSignCount)
	}
	if m.cloneWarning != nil {
		fields = append(fields, webauthncredential.FieldCloneWarning)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebAuthnCredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webauthncredential.FieldName:
		return m.Name()
	case webauthncredential.FieldCreatedAt:
		return m.CreatedAt()
	case webauthncredential.FieldCredentialId:
		return m.CredentialId()
	case webauthncredential.FieldPublicKey:
		return m.PublicKey()
	case webauthncredential.FieldAttestationType:
		return m.AttestationType()
	case webauthncredential.FieldTransport:
		return m.Transport()
	case webauthncredential.FieldAaguid:
		return m.Aaguid()
	case webauthncredential.FieldSignCount:
		return m.SignCount()
	case webauthncredential.FieldCloneWarning:
		return m.CloneWarning()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebAuthnCredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webauthncredential.FieldName:
		return m.OldName(ctx)
	case webauthncredential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webauthncredential.FieldCredentialId:
		return m.OldCredentialId(ctx)
	case webauthncredential.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case webauthncredential.FieldAttestationType:
		return m.OldAttestationType(ctx)
	case webauthncredential.FieldTransport:
		return m.OldTransport(ctx)
	case webauthncredential.FieldAaguid:
		return m.OldAaguid(ctx)
	case webauthncredential.FieldSignCount:
		return m.OldSignCount(ctx)
	case webauthncredential.FieldCloneWarning:
		return m.OldCloneWarning(ctx)
	}
	return nil, fmt.Errorf("unknown WebAuthnCredential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnCredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webauthncredential.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webauthncredential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webauthncredential.FieldCredentialId:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialId(v)
		return nil
	case webauthncredential.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case webauthncredential.FieldAttestationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestationType(v)
		return nil
	case webauthncredential.FieldTransport:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransport(v)
		return nil
	case webauthncredential.FieldAaguid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAaguid(v)
		return nil
	case webauthncredential.FieldSignCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignCount(v)
		return nil
	case webauthncredential.FieldCloneWarning:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloneWarning(v)
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebAuthnCredentialMutation) AddedFields() []string {
	var fields []string
	if m.addsignCount != nil {
		fields = append(fields, webauthncredential.FieldSignCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebAuthnCredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webauthncredential.FieldSignCount:
		return m.AddedSignCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebAuthnCredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webauthncredential.FieldSignCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignCount(v)
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebAuthnCredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebAuthnCredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebAuthnCredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WebAuthnCredential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebAuthnCredentialMutation) ResetField(name string) error {
	switch name {
	case webauthncredential.FieldName:
		m.ResetName()
		return nil
	case webauthncredential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webauthncredential.FieldCredentialId:
		m.ResetCredentialId()
		return nil
	case webauthncredential.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case webauthncredential.FieldAttestationType:
		m.ResetAttestationType()
		return nil
	case webauthncredential.FieldTransport:
		m.ResetTransport()
		return nil
	case webauthncredential.FieldAaguid:
		m.ResetAaguid()
		return nil
	case webauthncredential.FieldSignCount:
		m.ResetSignCount()
		return nil
	case webauthncredential.FieldCloneWarning:
		m.ResetCloneWarning()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebAuthnCredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, webauthncredential.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebAuthnCredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webauthncredential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebAuthnCredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebAuthnCredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebAuthnCredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, webauthncredential.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebAuthnCredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case webauthncredential.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebAuthnCredentialMutation) ClearEdge(name string) error {
	switch name {
	case webauthncredential.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebAuthnCredentialMutation) ResetEdge(name string) error {
	switch name {
	case webauthncredential.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WebAuthnCredential edge %s", name)
}
